{"pages":[],"posts":[{"title":"Machine Learning : ROC and AUC","text":"机器学习之ROC和AUC 1.ROC：在机器学习理论中，可用ROC曲线来分析二元分类模型。在二分类问题中，数据的标签通常用（0/1）来表示，在模型训练完成后进行测试时，会对测试集的每个样本计算一个介于 0~1 之间的概率，表征模型认为该样本为阳性的概率。我们可以选定一个阈值，将模型计算出的概率进行二值化，比如选定阈值等于0.5，那么当模型输出的值大于等于 0.5 时，我们就认为模型将该样本预测为阳性，也就是标签为 1，反之亦然。选定的阈值不同，模型预测的结果也会相应地改变。二元分类模型的单个样本预测有四种结果：真阳性（TP）：判断为阳性，实际也是阳性。伪阳性（FP）：判断为阳性，实际却是阴性。真阴性（TN）：判断为阴性，实际也是阴性。伪阴性（FN）：判断为阴性，实际却是阳性。这四种结果可以画成 2×2 的混淆矩阵：有了混淆矩阵，就可以定义ROC曲线了。ROC曲线将假阳性率（FPR）定义为X轴，真阳性率（TPR）定义为 Y 轴。其中：TPR：在所有实际为阳性的样本中，被正确地判断为阳性的样本比率。TPR=TP/(TP+FN)FPR：在所有实际为阴性的样本中，被错误地判断为阳性的样本比率。FPR=FP/(FP+TN)给定一个二分类模型和它的阈值，就可以根据所有测试集样本点的真实值和预测值计算出一个(X=FPR,Y=TPR)坐标点，使用单点绘图方法即可得到 ROC 曲线。 AUC：AUC 的全称是 Area under the Curve of ROC，也就是 ROC 曲线下方的面积。在机器学习领域，经常用 AUC 值来评价一个二分类模型的训练效果。AUC 被定义为 ROC 曲线下的面积，显然这个面积的数值不会大于 1。在检验模型时，AUC 值越大的模型，正确率越高。例如：已经得出一系列样本被划分为正类的概率，按照大小排序，下图是一个示例，图中共有 20 个测试样本，“Class”一栏表示每个测试样本真正的标签（P 表示正样本，N 表示负样本），“Score”表示每个测试样本属于正样本的概率。接下来，从高到低依次将“Score”值作为阈值 threshold，当测试样本属于正样本的概率大于或等于这个 threshold 时，认为它为正样本，否则为负样本。举例来说，对于图中第 4 个样本，其“Score”值为 0.6，那么样本 1、2、3、4 都被认为是正样本，因为它们的“Score”值都大于等于 0.6，而其他样本则都认为是负样本。每次选取一个不同的 threshold，就可以得到一组 FPR 和 TPR，即 ROC 曲线上的一点。这样一来，一共得到了 20 组 FPR 和 TPR 的值，将它们画成 ROC 曲线的结果如下图：AUC(Area under Curve)：ROC 曲线下的面积，介于 0.1 和 1 之间。AUC 作为数值可以直观地评价分类器的好坏，值越大越好。","path":"2019/07/07/Machine-Learning-ROC-and-AUC/","date":"07-07","excerpt":"","tags":[]},{"title":"ROS-Learning-Notes","text":"ROS学习笔记 ROS的基本思想：无须改动就能够在不同的机器人上复用代码。基于此，我们就可以在不同的机器人上分享和复用已经实现的功能。 一、ROS文件系统级1、与其他操作系统类似，一个ROS程序的不同组件要放在不同的文件夹下。这些文件夹是根据功能的不同来对文件进行组织的。(1)功能包(Package)：一个功能包具有创建ROS程序的最小结构和最少内容。一个package可包含ROS运行的进程（节点）、配置文件等。(2)功能包清单(Package Manifest)：功能包清单提供关于功能包、许可关系、依赖关系、编译标志等信息。一个包的清单有一个名为package.xml的文件管理。(3)元功能包(MetaPackage)：将几个具有某些功能的功能包组织在一起，就是一个元功能包。在ROS系统中，存在大量不同用途的元功能包，例如导航功能包集。(4)元功能包清单(MetaPackage Manifest)：也由一个名为package.xml的文件管理，但有一个XML格式的导出标记。它在结构上有一定的限制。(5)消息类型(Message(msg) type)：消息是一个进程发送到其他进程的信息。ROS系统中有很多的标准类型消息。消息类型的说明储存在my_package/msg/MyMessageType.msg中，也就是对应功能包的msg文件夹下。(6)服务类型(Service(srv) type)：服务描述说明储存在my_package/srv/MySeviceType.srv中，定义了在ROS中由每个进程提供的关于服务请求和响应的数据结构。 2、工作空间(1)源文件空间(source space)：在源空间(src)文件夹中，放置了功能包、项目、复制的包等。在这个空间中，最重要的一个文件是CMakeLists.txt。当在工作空间配置包时，src文件夹中的CMakeLists.txt会调用CMake。这个文件是通过catkin_init_workspace命令创建的。(2)编译空间(build space)：在build文件夹中，CMake和catkin为功能包项目保存缓存信息、配置和其他中间文件。(3)开发空间(development(devel) space)：在devel文件夹中，用来保存编译后的程序，这些是无需安装就能用来测试的程序。一旦项目通过测试，就可以安装或导出功能包从而与其他开发人员分享。 3、功能包：package(1)功能包指的是一种特定结构的文件和文件夹组合。(2)package的最精简结构(判断是否是一个package): (3)package中的代码格式： (4)package中的自定义通信格式： (5)package的组成： (6)package.xml文件package.xml必须在每个功能包中，它用来说明此包相关的各类信息。打开一个package.xml文件，可以看到包的名称、依赖关系等信息。功能包清单的作用就是为了方便安装和分发这些功能包。1234567891011#package.xml&lt;package&gt; &lt;name&gt; #包名 &lt;version&gt; #版本号 &lt;description&gt; #包描述 &lt;maintainer&gt; #维护者 &lt;license&gt; #许可证 &lt;buildtool_depend&gt; #编译工具 &lt;build_depend&gt; #编译时的依赖 &lt;run_depend&gt; #运行时的依赖&lt;/package&gt; 在package.xml文件中两个典型的标记是&lt;build_depend&gt;和&lt;run_depend&gt;,&lt;build_depend&gt;标记会显示当前功能包安装之前必须先安装哪些功能包，因为新的功能包会使用其他包的一些功能。&lt;run_depend&gt;标记会显示运行功能包中代码所需要的包。 二、ROS计算图级：1、ROS会创建一个连接到所有进程的网络，在系统中的任何一个节点都可以访问此网络，并通过该网络与其他节点交互，获取其他节点发送的消息，并将自身数据发布到网络上。 2、节点：node节点是主要的计算执行进程。如果想要有一个可以与其他节点进行交互的进程，那么需要创建一个节点，并将此节点连接到ROS网络。通常情况下，系统包含能够实现不同功能的多个节点。最好让众多节点都具有单一的功能，而不是在系统中创建一个包罗万象的大节点。节点都是各自独立的可执行文件，能够通过主题、服务或参数服务器与其他进程（节点）通信。ROS通过使用节点将代码和功能解耦，提高了系统容错能力和可维护性，使系统简化。节点在系统中必须有唯一的名称。节点使用特定名称与其他节点进行通信而不产生二义性。节点可以使用不同的库进行编写，如roscpp和rospy。roscpp基于C++，rospy基于python。ROS提供了处理节点和显示节点信息的工具，如rosnode。rosnode是一个用于显示节点信息的命令行工具。支持的命令如下： ·rosnode info NODE 输出当前节点信息 ·rosnode kill NODE 结束当前运行节点进程或发送给定信号 ·rosnode list 列出当前活动节点 ·rosnode machine hostname 列出某一特定计算机上运行的节点或列出主机名称 ·rosnode ping NODE 测试节点间的连通性 ·rosnode cleanup 将无法访问节点的注册信息删除 3、主题：topic每个消息都必须有一个名称以便被ROS网络分发。当一个节点发送数据时，我们就说该节点正在向主题发布消息。节点可以通过订阅某个主题，接收来自其他节点的消息。一个节点可以订阅一个主题，而不需要任何其他节点同时发布该主题，这就保证了消息的发布者和订阅者之间的解耦，完全无须知道对方的存在。主题的名称必须是唯一的，否则在同名主题之间的消息路由就会发生错误。主题是节点间用来传输数据的总线。通过主题进行消息传输不需要节点之间连接。这就意味着发布者和订阅者之间不需要知道彼此是否存在。一个主题可以有多个订阅者，也可以有多个发布者，但是用不同的节点发布同样的主题时要慎重，否则会产生冲突。每个主题都是强类型的，发布到主题上的消息必须与主题的ROS消息类型相匹配，并且节点只能接收类型匹配的消息。节点想要订阅主题，就必须具有相同的类型。ROS的主题可以使用TCP/IP和UDP传输。基于TCP传输称为TCPROS，它使用TCP/IP长连接，这时ROS默认的传输方式。基于UDP传输称为UDPROS，它是一种低延迟高效率的传输方式，但可能产生数据丢失，所以它最适合于像远程操控的任务。ROS有一个rostopic工具用于主题操作，它是一个命令行工具，允许我们获取主题的相关信息或直接在网络上发布数据。支持的命令如下： ·rostopic bw /topic 显示主题所使用的宽带 ·rostopic echo /topic 将消息输出到屏幕 ·/font&gt;rostopic find message_type 按照类型查找主题 ·rostopic hz /topic 显示主题的发布频率 ·rostopic info /topic 输出主题的信息，例如其消息类型、发布者、订阅者 ·rostopic list 输出活动的主题 ·rostopic pub /topic type args 将数据发布到主题，它允许我们直接从命令行中对任意主题创建和发布数据 ·rostopic type /topic 输出主题的类型，即主题中发布的消息类型 4、服务：service 5、消息：message 6、节点管理器 7、参数服务器 三、ROS-Academy-for-Beginners命令演示1、启动gazebo1roslaunch robot_sim_demo robot_spawn.launch 2、启动键盘控制机器人移动1rosrun robot_sim_demo robot_keyboard_teleop.py 3、启动rgb摄像头1rosrun image_view image_view image:=/camera/rgb/image_raw 4、启动深度摄像头1rosrun image_view image_view image:=/camera/depth/image_raw 5、启动navigation模拟1roslaunch navigation_sim_demo amcl_demo.launch 6、启动rviz，显示建立好的地图1roslaunch navigation_dim_demo view_navigation.launch","path":"2019/06/01/ROS-Learning-Notes/","date":"06-01","excerpt":"","tags":[]},{"title":"Machine-Learning-Vectorization","text":"大数据挑战赛:机器学习之域名向量化 使用字符嵌入模型(Character Embedding)完成域名的向量化Character Embedding 方法将每个单独字符视为一个特征，根据这个规则对所有域名的特征进行提取、去重，结果作为所有域名具有的特征。每个特征都对应着一个索引，对于域名中的每个字符，都用对应的特征索引进行替代，从而得到域名的索引表示。随后将其输入Embedding网络层，输出的向量就是域名的向量表示。 话不多说，直接在命令行中演示:1、现随便给出几个个域名1&gt;&gt;&gt; domains = [&apos;jobhero-com-1.disqus.com&apos;, &apos;vstu.by&apos;, &apos;diamondpeak.com&apos;, &apos;netcollections.net&apos;, &apos;pfgc.com.s7a1.psmtp.com&apos;, &apos;dudeiwantthat.com&apos;, &apos;sascha-frank.com&apos;, &apos;milavia.net&apos;] 123&gt;&gt;&gt; domains[&apos;jobhero-com-1.disqus.com&apos;, &apos;vstu.by&apos;, &apos;diamondpeak.com&apos;, &apos;netcollections.net&apos;, &apos;pfgc.com.s7a1.psmtp.com&apos;, &apos;dudeiwantthat.com&apos;, &apos;sascha-frank.com&apos;, &apos;milavia.net&apos;] 2、1&gt;&gt;&gt; from sklearn import feature_extraction 3、分割字符1234&gt;&gt;&gt; ngram_vectorizer = feature_extraction.text.CountVectorizer(analyzer=&apos;char&apos;, ngram_range=(2, 2)) &gt;&gt;&gt; count_vec = ngram_vectorizer.fit_transform(domains) analyzer=‘char’表示以字符串的方式将数据块化，ngram_range=(2, 2)表示每两个字符进行分割，下面为输出示例： 4、将domains以每两个字符进行分割，以列表形式展现：12345678&gt;&gt;&gt; print(ngram_vectorizer.get_feature_names())[&apos;-1&apos;, &apos;-c&apos;, &apos;-f&apos;, &apos;.b&apos;, &apos;.c&apos;, &apos;.d&apos;, &apos;.n&apos;, &apos;.p&apos;, &apos;.s&apos;, &apos;1.&apos;, &apos;7a&apos;, &apos;a-&apos;, &apos;a.&apos;, &apos;a1&apos;, &apos;ak&apos;, &apos;am&apos;, &apos;an&apos;, &apos;as&apos;, &apos;at&apos;, &apos;av&apos;, &apos;bh&apos;, &apos;by&apos;, &apos;c.&apos;, &apos;ch&apos;, &apos;co&apos;, &apos;ct&apos;, &apos;de&apos;, &apos;di&apos;, &apos;dp&apos;, &apos;du&apos;, &apos;ea&apos;, &apos;ec&apos;, &apos;ei&apos;, &apos;er&apos;, &apos;et&apos;, &apos;fg&apos;, &apos;fr&apos;, &apos;gc&apos;, &apos;ha&apos;, &apos;he&apos;, &apos;ia&apos;, &apos;il&apos;, &apos;io&apos;, &apos;is&apos;, &apos;iw&apos;, &apos;jo&apos;, &apos;k.&apos;, &apos;la&apos;, &apos;le&apos;, &apos;ll&apos;, &apos;m-&apos;, &apos;m.&apos;, &apos;mi&apos;, &apos;mo&apos;, &apos;mt&apos;, &apos;nd&apos;, &apos;ne&apos;, &apos;nk&apos;, &apos;ns&apos;, &apos;nt&apos;, &apos;o-&apos;, &apos;ob&apos;, &apos;ol&apos;, &apos;om&apos;, &apos;on&apos;, &apos;p.&apos;, &apos;pe&apos;, &apos;pf&apos;, &apos;ps&apos;, &apos;qu&apos;, &apos;ra&apos;, &apos;ro&apos;, &apos;s.&apos;, &apos;s7&apos;, &apos;sa&apos;, &apos;sc&apos;, &apos;sm&apos;, &apos;sq&apos;, &apos;st&apos;, &apos;t.&apos;, &apos;tc&apos;, &apos;th&apos;, &apos;ti&apos;, &apos;tp&apos;, &apos;tt&apos;, &apos;tu&apos;, &apos;u.&apos;, &apos;ud&apos;, &apos;us&apos;, &apos;vi&apos;, &apos;vs&apos;, &apos;wa&apos;] 5、以字典形式展现，key：分割的字符 value：索引12345678910111213&gt;&gt;&gt; print(ngram_vectorizer.vocabulary_)&#123;&apos;jo&apos;: 45, &apos;ob&apos;: 61, &apos;bh&apos;: 20, &apos;he&apos;: 39, &apos;er&apos;: 33, &apos;ro&apos;: 71, &apos;o-&apos;: 60, &apos;-c&apos;: 1, &apos;co&apos;: 24, &apos;om&apos;: 63, &apos;m-&apos;: 50, &apos;-1&apos;: 0, &apos;1.&apos;: 9, &apos;.d&apos;: 5, &apos;di&apos;: 27, &apos;is&apos;: 43, &apos;sq&apos;: 77, &apos;qu&apos;: 69, &apos;us&apos;: 88, &apos;s.&apos;: 72, &apos;.c&apos;: 4, &apos;vs&apos;: 90, &apos;st&apos;: 78, &apos;tu&apos;: 85, &apos;u.&apos;: 86, &apos;.b&apos;: 3, &apos;by&apos;: 21, &apos;ia&apos;: 40, &apos;am&apos;: 15, &apos;mo&apos;: 53, &apos;on&apos;: 64, &apos;nd&apos;: 55, &apos;dp&apos;: 28, &apos;pe&apos;: 66, &apos;ea&apos;: 30, &apos;ak&apos;: 14, &apos;k.&apos;: 46, &apos;ne&apos;: 56, &apos;et&apos;: 34, &apos;tc&apos;: 80, &apos;ol&apos;: 62, &apos;ll&apos;: 49, &apos;le&apos;: 48, &apos;ec&apos;: 31, &apos;ct&apos;: 25, &apos;ti&apos;: 82, &apos;io&apos;: 42, &apos;ns&apos;: 58, &apos;.n&apos;: 6, &apos;pf&apos;: 67, &apos;fg&apos;: 35, &apos;gc&apos;: 37, &apos;c.&apos;: 22, &apos;m.&apos;: 51, &apos;.s&apos;: 8, &apos;s7&apos;: 73, &apos;7a&apos;: 10, &apos;a1&apos;: 13, &apos;.p&apos;: 7, &apos;ps&apos;: 68, &apos;sm&apos;: 76, &apos;mt&apos;: 54, &apos;tp&apos;: 83, &apos;p.&apos;: 65, &apos;du&apos;: 29, &apos;ud&apos;: 87, &apos;de&apos;: 26, &apos;ei&apos;: 32, &apos;iw&apos;: 44, &apos;wa&apos;: 91, &apos;an&apos;: 16, &apos;nt&apos;: 59, &apos;tt&apos;: 84, &apos;th&apos;: 81, &apos;ha&apos;: 38, &apos;at&apos;: 18, &apos;t.&apos;: 79, &apos;sa&apos;: 74, &apos;as&apos;: 17, &apos;sc&apos;: 75, &apos;ch&apos;: 23, &apos;a-&apos;: 11, &apos;-f&apos;: 2, &apos;fr&apos;: 36, &apos;ra&apos;: 70, &apos;nk&apos;: 57, &apos;mi&apos;: 52, &apos;il&apos;: 41, &apos;la&apos;: 47, &apos;av&apos;: 19, &apos;vi&apos;: 89, &apos;a.&apos;: 12&#125; 6、12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&gt;&gt;&gt; print(count_vec) (0, 4) 1 (第0个domains列表元素，词典中索引为 4的元素)， 词频 (0, 72) 1 (第0个domains列表元素，词典中索引为72的元素)， 词频 (0, 88) 1 (第0个domains列表元素，词典中索引为88的元素)， 词频 (0, 69) 1 (0, 77) 1 (0, 43) 1 (0, 27) 1 (0, 5) 1 (0, 9) 1 (0, 0) 1 (0, 50) 1 (0, 63) 2 (0, 24) 2 (0, 1) 1 (0, 60) 1 (0, 71) 1 (0, 33) 1 (0, 39) 1 (0, 20) 1 (0, 61) 1 (0, 45) 1 (1, 21) 1 (1, 3) 1 (1, 86) 1 (1, 85) 1 : : (6, 57) 1 (6, 70) 1 (6, 36) 1 (6, 2) 1 (6, 11) 1 (6, 23) 1 (6, 75) 1 (6, 17) 1 (6, 74) 1 (6, 38) 1 (6, 16) 1 (6, 46) 1 (6, 4) 1 (6, 63) 1 (6, 24) 1 (7, 12) 1 (7, 89) 1 (7, 19) 1 (7, 47) 1 (7, 41) 1 (7, 52) 1 (7, 6) 1 (7, 34) 1 (7, 56) 1 (7, 40) 1 7、将结果转化为矩阵的表示方式：1234567891011121314151617&gt;&gt;&gt; print(count_vec.toarray())[[1 1 0 0 1 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 2 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 1 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 1 0 2 0 0 0 0 0 1 0 1 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0] [0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 1 0 0 0 1 0][0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 1 0 0 1 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0][0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 1 0 0 2 0 0 0 0 0 0 0 1 0 0 0 0 0 1 1 0 0 0 0 0 0 2 0 1 0 0 0 1 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0][0 0 0 0 2 0 0 1 1 1 1 0 0 1 0 0 0 0 0 0 0 0 1 0 2 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 2 0 1 0 1 1 0 0 0 0 1 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0][0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 1 0 1 0 0 1 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 1 0 0 1 0 0 0 1][0 0 1 0 1 0 0 0 0 0 0 1 0 0 0 0 1 1 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 1 0 0 0 0 0 1 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0]]","path":"2019/05/21/Machine-Learning-Vectorization/","date":"05-21","excerpt":"","tags":[]},{"title":"PCL-Learning-Notes","text":"点云库(PCL:Point Cloud Library)学习笔记 1、了解名词(1)点云：通过测量仪器得到的产品外观表面的点数据集合称之为点云，使用三维激光扫描仪或照相式扫描仪得到的点云，点数量比较大并且比较密集，叫密集点云。 点云是在和目标表面特性的海量点集合。根据激光测量原理得到的点云，包括三维坐标(XYZ)和激光反射强度(Intensity)。根据摄影测量原理得到的点云，包括三维坐标(XYZ)和颜色信息(RGB)。结合激光测量和摄影测量原理得到点云，包括三维坐标(XYZ)、激光反射强度(Intensity)和颜色信息(RGB)。在获取物体表面每个采样点的空间坐标后，得到的是一个点的集合，称之为“点云”(Point Cloud)。 当一束激光照射到物体表面时，所反射的激光会携带方位、距离等信息。若将激光束按照某种轨迹进行扫描，便会边扫描边记录到反射的激光点信息，由于扫描极为精细，则能够得到大量的激光点，因而就可形成激光点云。 (2)SLAM，即时定位与制图，包含3个关键词：实时、定位、制图，就是实时完成定位和制图的任务，这就是SLAM要解决的基本任务。按照使用的传感器分为激光SLAM（LOAM、V-LOAM、cartographer）与视觉SLAM，其中视觉SLAM又可分为单目SLAM（MonoSLAM、PTAM、DTAM、LSD-SLAM、ORB-SLAM（单目为主）、SVO）、双目SLAM（LIBVISO2、S-PTAM等）、RGBD SLAM（KinectFusion、ElasticFusion、Kintinous、RGBD SLAM2、RTAB SLAM）；视觉SLAM由前端（视觉里程计）、后端（位姿优化）、闭环检测、制图4个部分组成。 (3)Kinect RGB-D摄像机包含三个镜头，一个彩色摄像头，一个红外发射器和一个红外线CMOS摄像头。其中彩色摄像头可以获取彩色图像，红外线发射器和红外线CMOS摄像头共同组成了三维深度传感器。使用Kinect可以得到一副RGB图像和与之对应的深度图像，两种图像可以合成点云图。 2、kinect标定视觉SLAM中通过相机模型来生成三维点云数据，需要对Kinect进行标定。Kinetc能同时获取彩色图像和深度图像，需要分别对两种图像进行标定。 3、点线特征提取 (1)基于点线特征的三维地图构建算法主要包含三个模块：前端视觉里程计、后端优化和闭环优化。视觉里程计实时处理视频流，通过点线特征匹配求解相机的当前位姿；后端优化维护局部地图并对视觉里程计估计的初始位姿进行局部优化；闭环优化在检测到闭环后，通过闭环校正和全局优化得到全局一致的轨迹和地图。(视觉里程计：视觉里程计（VO），它根据相邻图像的信息粗略的估计出相机的运动，给后端提供较好的初始值。VO的实现方法可以根据是否需要提取特征分为两类：基于特征点的方法，不使用特征点的直接方法。 基于特征点的VO运行稳定，对光照、动态物体不敏感。) (2)点特征提取1)FAST特征点提取算法FAST算法的思想很简单：如果一个像素与周围邻域的像素差别较大（过亮或者过暗），那么可以认为该像素是一个角点。和其他的特征点提取算法相比，FAST算法只需要比较像素和其邻域像素的灰度值大小，十分便捷。FAST算法提取角点的步骤：·在图像中选择像素p，假设其灰度值为：Ip·设置一个阈值T，例如：Ip的20%·选择p周围半径为3的圆上的16个像素，作为比较像素·假设选取的圆上有连续的N个像素大于Ip+T或者Ip−T，那么可以认为像素p就是一个特征点。（N通常取12，即为FAST-12；常用的还有FAST-9,FAST-11）。FAST算法只检测像素的灰度值，其运算速度极快，同时不可避免的也有一些缺点。·检测到的特征点过多并且会出现“扎堆”的现象。这可以在第一遍检测完成后，使用非最大值抑制（Non-maximal suppression），在一定区域内仅保留响应极大值的角点，避免角点集中的情况。·FAST提取到的角点没有方向和尺度信息。 2)BRIEF描述子BRIEF是一种二进制的描述子，其描述向量是0和1表示的二进制串。0和1表示特征点邻域内两个像素（p和q）灰度值的大小：如果p比q大则选择1，反正就取0。在特征点的周围选择128对这样的p和q的像素对，就得到了128维由0，1组成的向量。那么p和q的像素对是怎么选择的呢？通常都是按照某种概率来随机的挑选像素对的位置。BRIEF使用随机选点的比较，速度很快，而且使用二进制串表示最终生成的描述子向量，在存储以及用于匹配的比较时都是非常方便的，其和FAST的搭配起来可以组成非常快速的特征点提取和描述算法。 3)ORB算法ORB是目前来说非常好的能够进行的实时的图像特征提取和描述的算法，它改进了FAST特征提取算法，并使用速度极快的二进制描述子BRIEF。针对FAST特征提取的算法的一些缺点，ORB也做了相应的改进。·使用非最大值抑制，在一定区域内仅仅保留响应极大值的角点，避免FAST提取到的角点过于集中。·FAST提取到的角点数量过多且不是很稳定，ORB中可以指定需要提取到的角点的数量N，然后对FAST提取到的角点分别计算Harris响应值，选择前N个具有最大响应值的角点作为最终提取到的特征点集合。·FAST提取到的角点不具有尺度信息，在ORB中使用图像金字塔，并且在每一层金字塔上检测角点，以此来保持尺度的不变性。·FAST提取到的角点不具有方向信息，在ORB中使用灰度质心法(Intensity Centroid)来保持特征的旋转不变性。 4)OpenCV3中特征点的提取和匹配OpenCV中封装了常用的特征点算法（如SIFT,SURF，ORB等），提供了统一的接口，便于调用。 下面代码是OpenCV中使用其feature 2D 模块的示例代码:1234567891011121314151617181920Mat img1 = imread(&quot;F:\\\\image\\\\1.png&quot;);Mat img2 = imread(&quot;F:\\\\image\\\\2.png&quot;);// 1. 初始化vector&lt;KeyPoint&gt; keypoints1, keypoints2;Mat descriptors1, descriptors2;Ptr&lt;ORB&gt; orb = ORB::create();// 2. 提取特征点orb-&gt;detect(img1, keypoints1);orb-&gt;detect(img2, keypoints2);// 3. 计算特征描述符orb-&gt;compute(img1, keypoints1, descriptors1);orb-&gt;compute(img2, keypoints2, descriptors2); // 4. 对两幅图像的BRIEF描述符进行匹配，使用BFMatch，Hamming距离作为参考vector&lt;DMatch&gt; matches;BFMatcher bfMatcher(NORM_HAMMING);bfMatcher.match(descriptors1, descriptors2, matches); ·在OpenCV3中重新的封装了特征提取的接口，可统一的使用Ptr detector = FeatureDetector::create()来得到特征提取器的一个实例，所有的参数都提供了默认值，也可以根据具体的需要传入相应的参数。·在得到特征检测器的实例后，可调用的detect方法检测图像中的特征点的具体位置，检测的结果保存在vector向量中。·有了特征点的位置后，调用compute方法来计算特征点的描述子，描述子通常是一个向量，保存在Mat中。·得到了描述子后，可调用匹配算法进行特征点的匹配。上面代码中，使用了opencv中封装后的暴力匹配算法BFMatcher，该算法在向量空间中，将特征点的描述子一一比较，选择距离（上面代码中使用的是Hamming距离）较小的一对作为匹配点。上面代码匹配后的结果如下：特征点的匹配后的优化:特征的匹配是针对特征描述子的进行的，上面提到特征描述子通常是一个向量，两个特征描述子的之间的距离可以反应出其相似的程度，也就是这两个特征点是不是同一个。根据描述子的不同，可以选择不同的距离度量。如果是浮点类型的描述子，可以使用其欧式距离；对于二进制的描述子（BRIEF）可以使用其汉明距离（两个不同二进制之间的汉明距离指的是两个二进制串不同位的个数）。 有了计算描述子相似度的方法，那么在特征点的集合中如何寻找和其最相似的特征点，这就是特征点的匹配了。最简单直观的方法就是上面使用的：暴力匹配方法(Brute-Froce Matcher)，计算某一个特征点描述子与其他所有特征点描述子之间的距离，然后将得到的距离进行排序，取距离最近的一个作为匹配点。这种方法简单粗暴，其结果也是显而易见的，通过上面的匹配结果，也可以看出有大量的错误匹配，这就需要使用一些机制来过滤掉错误的匹配。 ·汉明距离小于最小距离的两倍:选择已经匹配的点对的汉明距离小于最小距离的两倍作为判断依据，如果小于该值则认为是一个错误的匹配，过滤掉；大于该值则认为是一个正确的匹配。其实现代码也很简单，如下：1234567891011121314151617// 匹配对筛选double min_dist = 1000, max_dist = 0;// 找出所有匹配之间的最大值和最小值for (int i = 0; i &lt; descriptors1.rows; i++)&#123; double dist = matches[i].distance; if (dist &lt; min_dist) min_dist = dist; if (dist &gt; max_dist) max_dist = dist;&#125;// 当描述子之间的匹配大于2倍的最小距离时，即认为该匹配是一个错误的匹配。// 但有时描述子之间的最小距离非常小，可以设置一个经验值作为下限vector&lt;DMatch&gt; good_matches;for (int i = 0; i &lt; descriptors1.rows; i++)&#123; if (matches[i].distance &lt;= max(2 * min_dist, 30.0)) good_matches.push_back(matches[i]);&#125; 结果如下：对比只是用暴力匹配的方法，进行过滤后的匹配效果好了很多。 ·交叉匹配针对暴力匹配，可以使用交叉匹配的方法来过滤错误的匹配。交叉过滤的是想很简单，再进行一次匹配，反过来使用被匹配到的点进行匹配，如果匹配到的仍然是第一次匹配的点的话，就认为这是一个正确的匹配。举例来说就是，假如第一次特征点A使用暴力匹配的方法，匹配到的特征点是特征点B；反过来，使用特征点B进行匹配，如果匹配到的仍然是特征点A，则就认为这是一个正确的匹配，否则就是一个错误的匹配。OpenCV中BFMatcher已经封装了该方法，创建BFMatcher的实例时，第二个参数传入true即可，BFMatcher bfMatcher(NORM_HAMMING,true)。 ·KNN匹配K近邻匹配，在匹配的时候选择K个和特征点最相似的点，如果这K个点之间的区别足够大，则选择最相似的那个点作为匹配点，通常选择K = 2，也就是最近邻匹配。对每个匹配返回两个最近邻的匹配，如果第一匹配和第二匹配距离比率足够大（向量距离足够远），则认为这是一个正确的匹配，比率的阈值通常在2左右。OpenCV中的匹配器中封装了该方法，上面的代码可以调用bfMatcher-&gt;knnMatch(descriptors1, descriptors2, knnMatches, 2);具体实现的代码如下：1234567891011121314151617181920212223242526const float minRatio = 1.f / 1.5f;const int k = 2;vector&lt;vector&lt;DMatch&gt;&gt; knnMatches;matcher-&gt;knnMatch(leftPattern-&gt;descriptors, rightPattern-&gt;descriptors, knnMatches, k);for (size_t i = 0; i &lt; knnMatches.size(); i++) &#123; const DMatch&amp; bestMatch = knnMatches[i][0]; const DMatch&amp; betterMatch = knnMatches[i][1]; float distanceRatio = bestMatch.distance / betterMatch.distance; if (distanceRatio &lt; minRatio) matches.push_back(bestMatch);&#125;const float minRatio = 1.f / 1.5f;const int k = 2;vector&lt;vector&lt;DMatch&gt;&gt; knnMatches;matcher-&gt;knnMatch(leftPattern-&gt;descriptors, rightPattern-&gt;descriptors, knnMatches, 2);for (size_t i = 0; i &lt; knnMatches.size(); i++) &#123; const DMatch&amp; bestMatch = knnMatches[i][0]; const DMatch&amp; betterMatch = knnMatches[i][1]; float distanceRatio = bestMatch.distance / betterMatch.distance; if (distanceRatio &lt; minRatio) matches.push_back(bestMatch); &#125; 将不满足的最近邻的匹配之间距离比率大于设定的阈值（1/1.5）匹配剔除。 ·RANSAC:另外还可采用随机采样一致性（RANSAC）来过滤掉错误的匹配，该方法利用匹配点计算两个图像之间单应矩阵，然后利用重投影误差来判定某一个匹配是不是正确的匹配。OpenCV中封装了求解单应矩阵的方法findHomography,可以为该方法设定一个重投影误差的阈值，可以得到一个向量mask来指定那些是符合该重投影误差的匹配点对，以此来剔除错误的匹配，代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445const int minNumbermatchesAllowed = 8;if (matches.size() &lt; minNumbermatchesAllowed) return;//Prepare data for findHomographyvector&lt;Point2f&gt; srcPoints(matches.size());vector&lt;Point2f&gt; dstPoints(matches.size());for (size_t i = 0; i &lt; matches.size(); i++) &#123; srcPoints[i] = rightPattern-&gt;keypoints[matches[i].trainIdx].pt; dstPoints[i] = leftPattern-&gt;keypoints[matches[i].queryIdx].pt;&#125;//find homography matrix and get inliers maskvector&lt;uchar&gt; inliersMask(srcPoints.size());homography = findHomography(srcPoints, dstPoints, CV_FM_RANSAC, reprojectionThreshold, inliersMask);vector&lt;DMatch&gt; inliers;for (size_t i = 0; i &lt; inliersMask.size(); i++)&#123; if (inliersMask[i]) inliers.push_back(matches[i]);&#125;matches.swap(inliers);const int minNumbermatchesAllowed = 8;if (matches.size() &lt; minNumbermatchesAllowed) return;//Prepare data for findHomographyvector&lt;Point2f&gt; srcPoints(matches.size());vector&lt;Point2f&gt; dstPoints(matches.size());for (size_t i = 0; i &lt; matches.size(); i++) &#123; srcPoints[i] = rightPattern-&gt;keypoints[matches[i].trainIdx].pt; dstPoints[i] = leftPattern-&gt;keypoints[matches[i].queryIdx].pt;&#125;//find homography matrix and get inliers maskvector&lt;uchar&gt; inliersMask(srcPoints.size());homography = findHomography(srcPoints, dstPoints, CV_FM_RANSAC, reprojectionThreshold, inliersMask);vector&lt;DMatch&gt; inliers;for (size_t i = 0; i &lt; inliersMask.size(); i++)&#123; if (inliersMask[i]) inliers.push_back(matches[i]);&#125;matches.swap(inliers); (3)线特征提取 4、前端视觉里程计位姿估计 5、后端优化视觉里程计能够增量式地构建环境地图，但其只考虑相邻之间位姿关系，长时间运行不可避免会产生累计误差，这样得到的地图是不准确的。后端优化环节把当前帧与更早的帧关联起来，加入更多的地图数据进行优化，从而降低累计误差。视觉SLAM中会有成千上万帧图像，后端优化并不会耗费巨大的计算量将每一帧都纳入优化，因此需要选择一些有代表性的帧作为关键帧。同时，为了便于后续跟踪，需要尽可能快速插入关键帧。 6、八叉树地图的构建点云地图是一种较为初级的地图表达方式，不能直接用于机器人的导航。八叉树地图中的每个节点表示一个立方体所包含的空间，通常称为体素。这个立方体递归地细分为八个子立方体，直到分割成最小的体素。最小体素的大小决定了八叉树的分辨率，由于八叉树是一种分层数据结构，能够在任意层次切割得到不同分辨率的表达。八叉树在不同分辨率下的表示如图：由八叉树的表达方式可以看出，其优点在于：(1)压缩空间：八叉树的节点存储了是否被占据的信息，当节点的所有子节点全部被占据或是全不占据时，就无需展开此节点，能够大大节省内存空间。(2)更新地图：通过概率对数可以方便的对八叉树地图进行更新。(3)导航与避障：八叉树地图每个体素表示其被占据的概率，机器人可以很方便地对八叉树地图进行空间可行性分析和路径规划。并且八叉树地图分辨率可调，可以灵活地将不同分辨率的地图应用于不同层次的导航。","path":"2019/05/18/PCL-Learning-Notes/","date":"05-18","excerpt":"","tags":[]},{"title":"Turtlebot2 rgbslam_v2 三维地图建模","text":"Turtlebot2 rgbslam_v2 三维地图建模此篇文章转载博客:www.guyuehome.com/8601、启动UI 12$ roslaunch freenect_launch freenect.launch$ roslaunch rgbdslam rgbdslam.launch 或者：1$ roslaunch rgbdslam openni+rgbdslam.launch(启动界面) 2、启动底座和遥控12$ roslaunch turtlebot_bringup minimal.launch(启动底座)$ roslaunch turtlebot_teleop keyboard_teleop.launch(启动遥控) 3、建立地图按下rgbd-slam-v2的空白键，让机器人四处走起来。UI的状态栏会显示程序的运行状态，有提取特征、加入新Frame，等等。如果它成功匹配上，上图的点云就会更新，并且会跟着机器人转动。别看上面像是打了码一样的，最后出的点云图可是高清无码的。4、保存地图建模完成后，直接在菜单栏中选择保存成点云数据即可。5、查看地图然可以通过pcl_ros（http://wiki.ros.org/pcl_ros ）来查看保存的点云地图：1rosrun pcl_ros pcd_to_pointcloud quicksave.pcd 在rviz中显示pointcloud2数据：6、总结Rgbd-slam-v2是14年论文里提到的算法。它整合了SLAM领域里的各种技术：图像特征、回环检测、点云、图优化等等，是一个非常全面且优秀的程序。它的UI做的也很漂亮，可以在它的源代码上继续开发。缺点：在美观之外，由于要提特征（SIFT很费时）、渲染点云，这些事情是很吃资源的，导致算法实时性不太好。有时会发现它卡在那儿不动了，不得不等它一小会。机器人如果走的太快，很容易跟丢。","path":"2019/05/18/Turtlebot2-rgbslam-3D-Mapping/","date":"05-18","excerpt":"","tags":[]},{"title":"Turtlebot2 rgbdslam_v2环境配置","text":"Turtlebot2 rgbdslam_v2环境配置 1、创建一个工作空间，编译一遍123$ mkdir -p ~/catkin_ws/src$ cd ~/catkin_ws$ catkin_make 2、下载rgbdslam_v2代码包12345$ cd ~/catkin_ws/src$ wget -q http://github.com/felixendres/rgbdslam_v2/archive/kinetic.zip$ unzip kinetic.zip(把解压出来的文件名更改为rgbdslam_v2)$ sudo cp -a ~/catkin_ws/src/rgbdslam_v2 /opt/ros/kinetic/share 3、安装g2o的依赖sudo apt-get install libsuitesparse-dev4、创建eigen工作空间12345$ mkdir ~/src$ cd ~/src$ wget http://bitbucket.org/eigen/eigen/get/3.2.10.tar.bz2mkdir eigen$ tar -xvjf 3.2.10.tar.bz2 -C eigen --strip-components 1 5、创建g2o工作空间12345$ cd ~/src$ git clone https://github.com/felixendres/g2o.git$ cd ~/src/g2o$ mkdir ~/src/g2o/build$ cd ~/src/g2o/build 6、配置g2o代码包中的CMakeLists.txt文件1234567$ vi ~/src/g2o/CMakeLists.txt(如果不习惯vi 可以执行 sudo gedit ~/src/g2o/CMakeLists.txt 也可以使用atom文本编辑器打开)在251行中：将SET(G2O_EIGEN3_INCLUDE $&#123;EIGEN3_INCLUDE_DIR&#125; CACHE PATH &quot;Directory of Eigen3&quot;)替换为SET(G2O_EIGEN3_INCLUDE &quot;~/src/eigen&quot; CACHE PATH &quot;Directory of Eigen3&quot;)保存退出 7、编译g2o工作空间1234$ cd ~/src/g2o/build$ cmake ../$ make$ sudo make install 8、下载PCL1.8(点云库：Point Cloud Library)在此过程中，采用了很多方法，但都失败了，最后直接找到源代码的位置，下载zip文件(tar文件无法下载),下载之后放在~/src目录下解压。12$ cd ~/src$ unzip pcl-pcl-1.8.0.zip 9、配置PCL,使其支持C++2011123$ cd ~/src/pcl-pcl-1.8.0$ vi CMakeLists.txt(或者sudo gedit CMakeLists.txt)在146行(endif()下一行)中加入SET(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++11&quot;) 10、编译PCL1234567$ cd ~/src/pcl-pcl-1.8.0$ mkdir build$ cd build$ cmake ../$ make VERBOSE=1 (此步骤是为了验证PCL是否支持C++2011，如果能在输出中看到&quot;-std=c++11&quot;，则说明是支持的，没有问题,按Ctrl+C退出，执行下一行命令。)$ make$ sudo make install 11、配置rgbdslam_v2123456$ cd ~/catkin_ws/src/rgbdslam_v2$ vi CMakeLists.txt(sudo gedit CMakeLists.txt)在第六行中加入:add_compile_options(-std=c++11)之后将find_package(PCL 1.7 REQUIRED COMPONENTS common io)替换为:find_package(PCL 1.8 REQUIRED COMPONENTS common io) 12、编译rgbdslam_v2123456$ cd ~/catkin_ws$ source devel/setup.bash$ cd ~/catkin_ws/src/rgbdslam_v2$ catkin_make$ source devel/setup.bash$ echo &quot;source ~/catkin_ws/devel/setup.bash&quot; &gt;&gt; ~/.bashrc 13、环境测试123$ roslaunch freenect_launch freenect.launch(或者输入:roslaunch openni_launch openni.launch,如果没有设备连接，会显示&quot;waiting for devices to be connected&quot;)$ roslaunch rgbdslam openni+rgbdslam.launch(运行此命令就可以看到一个UI的界面了) 14、查看地图1$ rosrun pcl_ros pcd_to_pointcloud quicksave.pcd 有关博客参考：https://hubpages.com/technology/Instructions-for-compiling-rgbdslam-v2-on-a-fresh-Ubuntu-1604-install-ros-kinetic-in-virtualboxhttps://blog.csdn.net/u011178262/article/details/83046256https://blog.csdn.net/yangtze_1006/article/details/51606680www.guyuehome.com/860https://www.cnblogs.com/gaoxiang12/p/4462518.htmlhttps://github.com/felixendres/rgbdslam_v2https://www.ncnynl.com/archives/201708/1931.html","path":"2019/05/18/Turtlebot2-rgbdslam-Environment/","date":"05-18","excerpt":"","tags":[]},{"title":"turtlebot2-kinetic环境配置","text":"Turtlebot2-kinetic环境配置 •安装准备1234$ sudo apt-get install python-rosdep python-wstool ros-kinetic-ros$ sudo apt-get install pyqt5-dev-tools$ sudo rosdep init$ rosdep update •分别建立三个工作空间rocon，kobuki，turtlebot，下载和编译源码•建立rocon目录，下载和编译，rocon都有对应的kinetic版本1234567$ mkdir ~/rocon$ cd ~/rocon$ wstool init -j4 src https://raw.github.com/robotics-in-concert/rocon/release/kinetic/rocon.rosinstall（注意：如该下载失败，到github中找到相应文件进行配置）$ source /opt/ros/kinetic/setup.bash$ rosdep install --from-paths src -i -y$ catkin_make •建立kobuki目录，下载和编译.123456$ mkdir ~/kobuki$ cd ~/kobuki$ wstool init -j4 src https://raw.githubusercontent.com/yujinrobot/yujin_tools/kinetic-devel/rosinstalls/kinetic/kobuki.rosinstall$ source ~/rocon/devel/setup.bash$ rosdep install --from-paths src -i -y$ catkin_make •建立turtlebot目录，下载和编译.123456$ mkdir ~/turtlebot$ cd ~/turtlebot$ wstool init -j4 src https://raw.github.com/yujinrobot/yujin_tools/kinetic-devel/rosinstalls/kinetic/turtlebot.rosinstall$ source ~/kobuki/devel/setup.bash$ rosdep install --from-paths src -i -y$ catkin_make •添加工作空间到bashrc文件123$ echo &quot;source ~/rocon/devel/setup.bash&quot; &gt;&gt; ~/.bashrc$ echo &quot;source ~/kobuki/devel/setup.bash&quot; &gt;&gt; ~/.bashrc$ echo &quot;source ~/turtlebot/devel/setup.bash&quot; &gt;&gt; ~/.bashrc •启用新环境：$ source ~/.bashrc•测试环境生效：$ roscd turtlebot能正常进入到目录就说明成功 •生成kobuki别名$ rosrun kobuki_ftdi create_udev_rules •安装kinect驱动$ sudo apt-get install ros-kinetic-openni-* ros-kinetic-openni2-* ros-kinetic-freenect-* Turtlebot-kinetic测试测试Turtlebot安装（Turtlebot和工作站） 在工控机中，新开终端输入$ roscore如果ROS安装正确显示$ started core service [/rosout] 如有问题，请检查安装步骤！检查别名： •输入检测命令：$ ls /dev/kobuki •会显示有对应的设备/dev/kobuki •如果没有，添加别名：$ rosrun kobuki_ftdi create_udev_rules •重插USB线，在进行上述的检测命令 •通过遥控移动（仅TurtleBot，通过Turtlebot的上网本操作） 1.打开Turtlebot开关，状态点亮。 2.启动Turtlebot，在上网本，打开一个新终端，运行如下命令：$ roslaunch turtlebot_bringup minimal.launch 3.启动键盘遥控，在上网本，打开另一个新终端，运行如下命令：$ roslaunch turtlebot_teleop keyboard_teleop.launch 4.点击键盘“i”前进。 通过发布主题命令 •命令：$ rostopic pub -r 10 /cmd_vel_mux/input/navi geometry_msgs/Twist &#39;{linear: {x: 0.1, y: 0.0, z: 0.0}, angular: {x: 0.0,y: 0.0,z: 0.0}}&#39;","path":"2019/05/16/Turtlebot2-Kinetic-Environment/","date":"05-16","excerpt":"","tags":[]},{"title":"turtlebot2-indigo环境配置","text":"Turtlebot2-indigo环境配置 安装步骤 有两种安装方法，一种直接的安装命令，另外一种源码编译安装，区别在于：直接安装命令是安装在电脑默认路径/opt/ros/indigo/share里面不便于更改代码，因为默认路径下文件一般有访问权限，无法直接更改，需要使用sudo chmod -R 777 /opt更改其权限，使得每个使用的人都可以更改；源码编译，安装的文件在Home主目录中,方便更改。 1、直接安装命令1$ sudo apt-get install ros-indigo-turtlebot ros-indigo-turtlebot-apps ros-indigo-turtlebot-interactions ros-indigo-turtlebot-simulator ros-indigo-kobuki-ftdi ros-indigo-rocon-remocon ros-indigo-rocon-qt-library ros-indigo-ar-track-alvar-msgs 2、源码方式安装 1)先安装依赖项123$ sudo apt-get install python-rosdep python-wstool ros-indigo-ros$ sudo rosdep init$ rosdep update 2)建立Turtlebot工作空间 #创建三个文件夹，分别存放rocon、kobuki、turtlebot，复制相应的代码、设置文件所在路径工作环境、编译123456$ mkdir ~/rocon$ cd ~/rocon$ wstool init -j5 src https://raw.github.com/robotics-in-concert/rocon/release/indigo/rocon.rosinstall$ source /opt/ros/indigo/setup.bash$ rosdep install --from-paths src -i -y$ catkin_make 123456$ mkdir ~/kobuki$ cd ~/kobuki$ wstool init src -j5 https://raw.github.com/yujinrobot/yujin_tools/master/rosinstalls/indigo/kobuki.rosinstall$ source ~/rocon/devel/setup.bash$ rosdep install --from-paths src -i -y$ catkin_make 123456$ mkdir ~/turtlebot$ cd ~/turtlebot$ wstool init src -j5 https://raw.github.com/yujinrobot/yujin_tools/master/rosinstalls/indigo/turtlebot.rosinstall$ source ~/kobuki/devel/setup.bash$ rosdep install --from-paths src -i -y$ catkin_make 安装完成后，测试命令：$ roslaunch turtlebot_bringup minimal.launch如果正常可以看到以下界面1234567891011121314... logging to /home/fjx/.ros/log/e9549e36-850f-11e8-ab48-543530c06929/roslaunch-giimbot-19656.logChecking log directory for disk usage. This may take awhile.Press Ctrl-C to interruptDone checking log file disk usage. Usage is &lt;1GB.started roslaunch server http://giimbot:36504/SUMMARY========PARAMETERS * /app_manager/auto_rapp_installation: False * /app_manager/auto_start_rapp: ...........(中间省略)process[interactions-12]: started with pid [19769]process[zeroconf/zeroconf-13]: started with pid [19781][ INFO] [1531316403.920700304]: Zeroconf: service successfully established [turtlebot][_ros-master._tcp][11311]","path":"2019/05/16/turtlebot2-Indigo-Environment/","date":"05-16","excerpt":"","tags":[]},{"title":"基于legacy引导方式的win7-linux双系统","text":"写到这篇文章，笔者还是很有感触，因为我在大一的时候给电脑装双系统，用的是上一篇文章win10-linux的常规方法，也是用U盘作为启动项，但死活就是安装不上。之后才发现原因，我电脑的win7系统的引导方式是legacy，而常规方法安装的linux系统恰好是uefi引导方式，硬装是装不上的。如果你的电脑也是legacy引导方式想装双系统，其实很简单，这篇文章就可以解决你的问题。 操作步骤 (1)准备两个东西： 1) ubuntu镜像文件，网上自行下载(最好是到官网上去下载，靠谱)，这里以ubuntu16.04为例。 2) EasyBCD软件，网上自行下载(最好是安装版，不要绿色版)。 (2)分区。计算机右键-管理-磁盘管理，选中一个磁盘(这里以D盘为例)右键磁盘压缩，压缩空间自己定，这个空间就是给linux系统，最好不要小于20G。 (3)打开EasyBCD软件，添加linux引导项。 (4)安装之后，点击配置，进行文件配置，然后就会出现一个menu.lst文件，我们要编辑这个文件 因为系统就是这个文件找到我们的Ubuntu的。 把下面的 英文 复制进去，把原来的全覆盖掉1234title Install Ubunturoot (hd0,0)kernel (hd0,0)/vmlinuz.efi boot=casper iso-scan/filename=/ubuntu-16.04.2-desktop-amd64.iso ro quiet splash locale=zh_CN.UTF-8initrd (hd0,0)/initrd.lz 特别注意: 1)上图代码中”ubuntu-16.04.2-desktop-amd64.iso”是你下载ubuntu系统文件名，这个文件名是可以修改的，但修改的名字一定要与写入的代码名字一致，否则将无法安装。 2)在64位中casper目录下为vmlinuz.efi，32位的才是vmlinuz（本人亲测，在安装过程中碰到error 15 file not find 错误，就是因为这个问题） 3)对于有的电脑上你的第一个盘符并不是C盘，在磁盘管理中可以看出，所以安装时需将(hd0,0)改为（hd0,1）(假设为第二个)。 (5)ubuntu-16.04.2-desktop-amd64.iso镜像文件用压缩软件或者虚拟光驱打开，找到casper文件夹，把里面的initrd.lz和vmlinuz.efi解压到C盘，把.disk文件夹也解压到C盘，然后在把ubuntu-16.04.2-desktop-amd64.iso文件也复制到C盘。当然你也可以将这三个文件复制到别的盘符，但一定要与代码中的盘符相对应。比如我想在把文件复制到D盘，则代码中要将(hd0,0)改为相应D盘的盘符(hd0,1)。 (6)重启，就会看到有2个启动菜单，我们选择NeoGrub引导加载器，过一会就出现ubuntu系统的界面。 (7)有的电脑是双显卡，重启可能会在出现ubuntu图标时卡住(如果没卡请忽略)，这时因为独立显卡的问题，需要把它禁用掉，重启到win7系统，将EasyBCD配置文件改为如下： 然后再重启，加载引导就可以进入ubuntu界面了。 (8)这个步骤非常重要，出现界面之后，不要着急点安装，按Ctrl+Alt+t打开终端，输入代码:sudo umount -l /isodevice这一命令取消掉对光盘所在驱动器的挂载(注意，这里的-l是-L的小写，-l与/isodevice之间有一个空格)，否则分区界面找不到分区。 (9)然后点击ubuntu桌面的”install ubuntu”进入安装，在进行到“安装类型”的时候，我们可以选择“安装ubuntu，与Windows7共存”，这样就可以不用自己分区，非常简便，我们也可以选择“其它选项”，这样就需要自己来分区(此处不详细讲解)，其他的安装步骤正常安装即可。安装完成后，如果刚才(7)界面卡住，先不要重启，因为新系统没有配置Grub文件，重启还会卡住。此时要按Ctrl+Alt+T打开终端，输入sudo gedit /boot/grub.cfg 在出现的文档中搜索splash，并在其后加一个空格然后输入nomodeset并保存文档，就OK了。 (10)重启，就可以看见粉色的引导界面，有“ubunut”和“windows7”(win7在最下面)，这就是ubuntu引导带着win7一起启动，至此双系统安装成功。 (11)进入ubuntu系统后，按Ctrl+Alt+t打开终端，输入”sudo mv /et/grub.d/30_os-prober /etc/grub.d/06_os-prober”然后输入密码回车，再输入”sudo update-grub”,输入密码回车，此时，win7系统引导就在最上面了，每次开机就默认进入win7系统。 (12)重启进入win7，打开EasyBCD，移除nerogrub引导项(此步骤不做也可，没有什么影响)。","path":"2019/04/29/基于legacy引导方式的win7-linux双系统/","date":"04-29","excerpt":"","tags":[]},{"title":"基于uefi引导方式的win10-linux双系统","text":"本篇文章是装win10-linux双系统最基本的方法，如果你的电脑是uefi引导的win10系统，这个方法可行。但是强调一点，如果是弘基电脑，那么请您绕行，对于弘基电脑来说，这种方法是不可行的。本人装过弘基电脑的双系统，但是装完之后会发现直接进入win10系统，没有linux的引导，还需要在win10系统中用EasyUEFI这个软件来手动添加linux引导项，非常的麻烦，之后还会有许多的bug，需要不定期的进行维护。本人也请教过专业人士，但也没有办法，弘基电脑就是只能这样。下面进入正题，常规方法安装双系统。 操作步骤 (1)准备三个东西： 1)ubuntuIOS镜像文件，网上自行下载(建议到官网下载，靠谱) 2)刻录软件，这里用的是rufus 3)U盘，最好不小于4G (2)分区。计算机右键-管理-磁盘管理，选中一个磁盘(这里以D盘为例)右键磁盘压缩，压缩空间自己定，这个空间就是给linux系统，最好不要小于20G。 (3)刻录系统文件。刻录之前插入你的U盘，格式化。打开rufus软件设备选择你插入的U盘，软件会自动识别，镜像文件就选择你下载好ubuntu镜像文件，其它都是默认，不用改变。 然后点击开始出现以下界面：选择以IOS镜像模式写入，点击OK，就开始刻录，完成之后点击关闭。 (4)拔出U盘，重启进入bios，设置U盘启动项，关机。 (5)插入U盘，启动电脑，按指定键进入选择启动项的界面，然后选择插入的U盘，回车之后就会看到ubuntu的引导界面。 (6)接下来选择第二个选项”Install Ubuntu”，进入安装。 (7)左边的栏里选择“中文简体”，之后点击安装Ubuntu (8)先不联网，直接安装。 (9)继续安装 (10)到了最关键的一步了，这个时候系统会提示你是否与windows10共存。如果是新手，我们可以选择与win10共存，这样就避免了分区，非常简便。如果你想自己管理你的分区，那么就选择其他选项进行自定义分区。这里选择与windows10共存。 注意:如果系统没提示你之前安装过windows，那么你的启动方式就错误了，你得回到BIOS页面下更改启动方式再次启动。 (11)选择上海。 (12)选择汉语。 (13)设置账号和密码。 (14)安装完成后重启系统会看到此界面，这就说明安装成功，ubuntu的引导带着win10的引导一起启动，这时可以选择你想进入的系统。这个界面排在第一位的是”ubuntu”,这样每次开机默认进入的是ubuntu系统，可以把win10系统排在第一位。 (15)进入ubuntu系统，按Ctrl+Altr+t打开命令行，输入命令：sudo gedit /etc/default/grub,要修改默认启动顺序，找到如下行GRUB_DEFAULT=0 该行就是启动时默认的选项,修改为自己Windows所在的值。例如我的启动项是(可以在启动界面看到)： 0.Ubuntu启动 1.Ubuntu配置 2.Windows启动 所以修改为GRUB_DEFAULT=2，重启后就可以看到，windows10排在了第一位，每次开机默认进入win10系统。","path":"2019/04/28/基于uefi引导方式的win10-linux双系统/","date":"04-28","excerpt":"","tags":[]},{"title":"基于python和机器学习的微信跳一跳小程序破解","text":"","path":"2019/04/28/基于python和机器学习的微信跳一跳小程序破解/","date":"04-28","excerpt":"","tags":[]},{"title":"最简单的方法重装win10系统","text":"到Microsoft官网下载安装工具,用这个工具安装win10系统非常方便。利用此工具不仅可以在原有系统重装win10，也可以用来做U盘启动项。https://www.microsoft.com/zh-cn/software-download/windows10 操作步骤 1.如果电脑系统还可以进入，那就没必要做U盘启动项，直接在现有的系统里重装win10。 (1)右键，以管理员身份运行下载好的工具，利用工具下载Windows10原版系统。 (2)选择第二个(下载IOS文件)，点下一步。 (3)把“对这台电脑使用推荐的选项”对号去掉，就可以选择想要的系统。 (4)此处选择IOS文件(U盘在后文中讲解)，点下一步。 (5)开始下载win10系统，这系统是原版的系统，个人认为比那些在其他网站上下载的乱七八糟的系统要好。 (6)将下载好的IOS文件解压到C盘之外的一个文件夹，这些文件就是安装系统所需要的文件啦。 (7)右键“setup.exe”，以管理员身份运行，就开始安装系统了。 (8)顺利进入安装向导，检查安装环境。 (9)不更新，直接安装，速度更快，点击下一步。 (10)这里选择win10专业版，可以根据自己的情况选择。 (11)点击下一步。 (12)看个人需要是否选择保留文件。 (13)确认无误后安装，点击下一步。 (14)开始安装，期间会多次重启，请耐心等待。 (15)这个不解释。 (16)不解释。 (17)不解释。 (18)选择针对个人。 (19)创建账户和密码。 (20)不解释。 (21)不解释。 (22)选择稍后再做。 (23)根据需要选择。 (24)一些设置。 (25)配置电脑硬件，等一会就好了。 (26)敬请开始吧！ (27)全新的win10系统！ (28)设置桌面图标：在桌面右键&gt;个性化&gt;主题&gt;桌面图标设置， 然后勾选你所需要显示的图标即可 (29)查看系统激活情况。右键此电脑&gt;属性查看，新系统是没有激活的，下载一个系统激活软件，进行激活。(此处不做过多讲解) 2.如果你的系统坏了，进不去了，这时你就要用U盘作为启动项安装系统。 (1)进入电脑Bios界面，设置引导模式，设置U盘启动。 (2)借一台同学的电脑，下载安装工具，文章开头已经写到。 (3)右键，以管理员身份运行下载好的工具，利用工具下载Windows10原版系统。 (4)选择第二个(做系统U盘)，点下一步。 (5)选择系统 (6)选择U盘，之后选择自己插入电脑的U盘，此过程是先下载系统，之后再刻录文件，所以时间比较漫长。如果你有自己的系统文件，比如之前下载IOS文件，就可以用刻录软件将系统直接刻录到U盘里。 (7)将刻录好的U盘插进要装系统的电脑，开机按指定键选择启动项。（不同电脑，按键不同。） (8)上下键选择U盘，回车进入即可安装系统，之后的步骤与上一种方法相同。 (9)U盘可以选择4G的U盘，刻录完之后就可以用这个U盘随时给电脑装系统啦。","path":"2019/04/27/最简单的方法重装win10系统/","date":"04-27","excerpt":"","tags":[]},{"title":"MBR分区与GPT分区互转方法","text":"系统引导的两种方式：UEFI启动模式：（GPT分区表格式+ UEFI启动模式+ x64的系统）Legacy启动模式：（MBR主引导记录分区格式+ Legacy启动模式）UEFI是新式的BIOS，Legacy是传统BIOS。在UEFI 模式下安装的系统，只能用UEFI模式引导；同理，如果在Legacy模式下安装的系统，也只能在Legacy模式下进系统。UEFI可以引导win7和win10系统，但是磁盘分区必须是GPT模式，系统必须是64位，UEFI不支持32位系统。legacy也可以引导win7和win10系统，磁盘分区必须是MBR模式，系统可以是32位也可以是64位。如果安装win10系统，推荐UEFI+GPT。因为win10系统默认就是uefi+gpt模式，这样才能发挥最佳性能。如果安装win7系统，推荐legacy+MBR。这两种搭配最常见的搭配，安装的系统不容易出现问题，其他的搭配个人觉得没有什么必要。当然，还是要根据自己的电脑情况来决定。比如一些老旧机型不支持uefi，只能是legacy引导。磁盘的两种分区格式：MBR，即主引导记录GPT，GUID的缩写GPT分区与MBR分区方法相比，GPT具有更多的优点。MBR分区表的硬盘最多能划分4个主分区磁盘，并且MBR最大仅支持2TB的硬盘，GPT分区表类型不受分区个数、硬盘大小的限制。通常情况下，如果win10系统想重装win7，需要把GPT转换为MBR，如果win7系统想重装win10，需要把MBR装换为GPT。注意：转换分区格式过程中均会清除磁盘中的所有分区和数据，所以在操作前请注意备份硬盘中的文件。 操作步骤： 1.GPT转换成MBR (1)通过U盘做一个简单的PE维护系统开机进入 (2)运行磁盘管理软件DiskGenius(一般PE都自带) (3)删除磁盘的所有分区 (4)在磁盘处右键，选择“转换分区表类型为MBR格式 (5)弹出如下提示窗口，选“确定” (6)至此，转换成MBR格式成功 (7)最后，保存一下更改 （8）给新转换好格式的磁盘重新分区一下即可正常使用；分区方法请看下图，按箭头顺序操作即可 2.MBR转换成GPT (1)进入PE系统 (2)运行磁盘管理软件DiskGenius(一般PE都自带) (3)删除原磁盘中的所有分区 (4)在磁盘处右键，选择“转换分区表类型为GUID格式” (5)弹出提示窗口，选“确定” (6)最后，别忘了保存一下更改 (7)给新转换好格式的磁盘重新分区一下即可正常使用；分区方法请看下图，按箭头顺序操作即可 (8)最终效果","path":"2019/04/26/MBR分区与GPT分区互转方法/","date":"04-26","excerpt":"","tags":[]}]}