<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>ROS中的launch文件 | 记录学习点滴</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/very-simple.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><!-- include the sidebar--><!-- include ./includes/sidebar.jade--><!-- Blog title and subtitle--><header><div class="container header"><a id="logo" href="/." class="title">记录学习点滴</a><span class="subtitle"></span><label id="toggle-menu" for="menu" onclick><i class="fa fa-bars"></i></label></div></header><!-- use checkbox hack for toggle nav-bar on small screens--><input id="menu" type="checkbox"><!-- Navigation Links--><nav id="nav"><div class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a></div></nav><div id="header-margin-bar"></div><!-- gallery that comes before the header--><div class="wrapper"><div class="container post-header"><h1>ROS中的launch文件</h1></div></div><div class="wrapper"><div class="container meta"><div class="post-time">2019-07-29</div></div></div><article><div class="container post"><p><font size="5">此篇记录ROS中的launch文件</font><br>一、launch文件简介<br>从ROS的角度看，机器人系统就是一堆node和topic（再添加一些parameter，service等）构成的网络（rosgraph），其中每个node都可以完成一定的功能。通常一个机器人运行时要开启很多node，如果一个一个的启动，比较麻烦。通过launch文件以及roslaunch命令可以一次性启动多个node，并且可以设置丰富的参数。</p>
<p>二、运行launch文件<br>1.借助ros package路径启动，格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ roslaunch pkg_name launchfile_name.launch</span><br></pre></td></tr></table></figure></p>
<p>2.直接给出launch文件的绝对路径，格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ roslaunch path_to_launchfile</span><br></pre></td></tr></table></figure></p>
<p>上述两种方式启动launch文件，都可以在后边添加参数，常见的参数有：<br>–screen: 令 ros node 的信息（如果有的话）输出到屏幕上，而不是保存在某个 log 文件中，这样比较方便调试<br>arg:=value: 如果 launch 文件中有待赋值的变量，可以通过这种方式赋值，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ roslaunch pkg_name launchfile_name model:=urdf/myfile.urdf  # launch file 中有参数 “model” 需要赋值</span><br></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ roslaunch pkg_name launchfile_name model:=&apos;$(find urdf_pkg)/urdf/myfile.urdf&apos; # 用 find 命令提供路径</span><br></pre></td></tr></table></figure></p>
<p>roalaunch命令运行时首先会检测系统的rosmaster是否运行，如果已经启动，就用现有的rosmaster；如果没有启动，会先启动rosmaster，然后再执行lanunch文件中的设置，一次性把多个节点按照我们预先的配置启动起来。需要注意的是，launch文件不需要再编译，设置好之后可以直接用上述方式运行。</p>
<p>三、launch文件的格式<br>launch文件本质上是一种xml文件，可以在头部添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br></pre></td></tr></table></figure></p>
<p>在某些编译器中可以高亮显示关键字，方便阅读。</p>
<p>与其它xml格式的文件类似，launch文件也是通过标签（tag）的方式书写。<br>主要的tag如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;launch&gt;                &lt;!--根标签--&gt;</span><br><span class="line">&lt;node&gt;                  &lt;!--需要启动的node及其参数--&gt;</span><br><span class="line">&lt;include&gt;               &lt;!--包含其他launch--&gt;</span><br><span class="line">&lt;machine&gt;               &lt;!--指定运行的机器--&gt;</span><br><span class="line">&lt;env-loader&gt;            &lt;!--设置环境变量--&gt;</span><br><span class="line">&lt;param&gt;                 &lt;!--定义参数到参数服务器--&gt;</span><br><span class="line">&lt;rosparam&gt;              &lt;!--加载yaml文件中的参数到参数服务器--&gt;</span><br><span class="line">&lt;arg&gt;                   &lt;!--定义变量--&gt;</span><br><span class="line">&lt;remap&gt;                 &lt;!--设定 topic 映射--&gt;</span><br><span class="line">&lt;group&gt;                 &lt;!--设定分组--&gt;</span><br><span class="line">&lt;/launch&gt;               &lt;!--根标签--&gt;</span><br></pre></td></tr></table></figure></p>
<p>1.<launch>,<node><br>这两个tag是launch文件的核心部分，基本格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;launch&gt;</span><br><span class="line">    &lt;node pkg=&quot;package_name&quot; type=&quot;executable_file&quot; name=&quot;node_name1&quot;/&gt;</span><br><span class="line">    &lt;node pkg=&quot;another_package&quot; type=&quot;another_executable&quot; name=&quot;another_node&quot;&gt;&lt;/node&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/launch&gt;</span><br></pre></td></tr></table></figure></node></launch></p>
<p>pkg：是节点所在的package名称<br>type：是package中的可执行文件，如果是python或者Julia编写的，就可能是.py或者.jl，如果是c++编写的，就会文件编译之后的可执行文件的名字。<br>name：是节点启动之后的名字，每一个节点都要有自己独一无二的名字。<br>注意：roslaunch不能保证node的启动顺序，因此launch文件中所有的node都应该对启动顺序有鲁棒性。</p>
<p>实际上<node>中除了pkg，type，name之外还可以设置更多参数，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;launch&gt;</span><br><span class="line">    &lt;node</span><br><span class="line">        pkg=&quot;&quot;</span><br><span class="line">        type=&quot;&quot;</span><br><span class="line">        name=&quot;&quot;  </span><br><span class="line">        respawn=&quot;true&quot; </span><br><span class="line">        required=&quot;true&quot;</span><br><span class="line">        launch-prefix=&quot;xterm -e&quot;</span><br><span class="line">        output=&quot;screen&quot;</span><br><span class="line">        ns=&quot;some_namespace&quot;</span><br><span class="line">    /&gt;</span><br><span class="line">&lt;/launch&gt;</span><br></pre></td></tr></table></figure></node></p>
<p>respawn:若该节点关闭，是否自动重新启动<br>required：若该节点关闭，是否关闭其他所有节点<br>launch-prefix：是否新开一个窗口执行。例如，需要通过窗口进行机器人移动控制的时候，应该为控制node新开一个窗口；或者node有些信息输出，不希望与其他node信息混杂在一起的时候。<br>output：默认情况下，launch启动node的信息会存入下面的log文件中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/.ros/log/run_id/node_name-number-stdout.log</span><br></pre></td></tr></table></figure></p>
<p>可以通过此处参数设置，令信息显示在屏幕上。<br>ns：将node归入不同namespace，即在node name前边加ns指定的前缀。</p>
<p>2.<remap><br>经常作为node tag的子tag出现，可以用来修改topic。在很多roanode源文件中，可能并没有指定接收的或者发送的topic，而仅仅是用input_topic和output_topic代替，这样在使用中需要将抽象的topic名字替换成具体场景中的topic名字。简单地说，remap的作用就是方便同一个node文件被应用到不同的环境中，用remap从外部修改一下topic即可，不需要改变源文件。<br>remap的常见格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;node pkg=&quot;some&quot; type=&quot;some&quot; name=&quot;some&quot;&gt;</span><br><span class="line">    &lt;remap from=&quot;origin&quot; to=&quot;new&quot; /&gt;</span><br><span class="line">&lt;/node&gt;</span><br></pre></td></tr></table></figure></remap></p>
<p>注意：如果这个remap是launch元素的一个child（子类），与node元素同一层级，并在launch元素内的最顶层，那么这个remap将会作用于后续所有的节点。</p>
<p>3.<include><br>这个标签的作用是将另外一个launch文件添加到本launch文件中，类似launch文件中的嵌套。<br>基本格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;include file=&quot;path-to-launch-file&quot; /&gt;</span><br></pre></td></tr></table></figure></include></p>
<p>上边的文件路径可以给具体路径，但是一般来说为了程序的可移植性，最好借助find命令给出文件路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;include file=&quot;$(find package-name)/launch-file-name&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>上述命令中，$(find package-name) 等价于本机中相应 package 的路径。这样即使换了其他机子，只要安装了同样的 package，就可以找到对应的路径。</p>
<p>有时，另一个 launch 引入的 node 可能需要统一命名，或者具有类似特征的 node 名字，比如 /vehicle1/gps, /vehicle1/lidar, /vehicle1/imu，即 node 具有统一的前缀，方便查找。这可以通过设置 ns （namespace）属性来实现，命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;include file=&quot;$(find package-name)/launch-file-name &quot; ns=&quot;namespace_name&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>4.<arg><br>声明一个参数的存在（每一个argument必须给它分配一个value（赋值））<br>赋值有以下两种实现方法:<br>在命令行中你可以这样做：给 roslaunch 提供一个 value :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ roslaunch package-name launch-file-name arg-name:=arg-value</span><br></pre></td></tr></table></figure></arg></p>
<p>另外，在launch文件中，你可以提供一个 value（赋值） 作为 arg 声明的一部分，使用下面的两种语法之一就可以：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;arg name=&quot;arg-name&quot; default=&quot;arg-value&quot; /&gt; </span><br><span class="line">&lt;arg name=&quot;arg-name&quot; value=&quot;arg-value&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>这两种语法的唯一不同是：命令行可以覆盖default的值，但是不能覆盖 value 。在例子launch文件  中，use_sim3 节点的 default 值为 0，所以它可以通过命令行改变值，就像下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ roslaunch agitr triplesim.launch use_sim3:=1</span><br></pre></td></tr></table></figure></p>
<p>如果我们修改了这个例子launch文件：使用value替换default。那么上面这个命令执行的时候会出    现错误，因为使用 value属性 配置的argument的值是不允许改变的。</p>
<p>5.<param><br>(1)group标签中的param标签的作用等同于rosparam set命令.<br>(2)node标签中的param标签设置为该节点的子元素.<br>(3)在launch文件中也支持等同与rosparam load 功能的rosparam标签，用于一次性加载大量的参数<br>(4)在launch文件中设置parameter,使用param标签:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;param name=&quot;param-name&quot; value=&quot;param-value&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>(5)在C++文件中,set或者get处理parameter参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ros::param::set(&quot;background_r&quot;, 255 );</span><br><span class="line">boolok = ros::param::get (PARAM_NAME, maxVel );</span><br></pre></td></tr></table></figure></p>
</div><!-- comment system--><div class="container"><hr></div></article><footer id="footer"><div class="container"><div class="bar"><div class="social"><a href="/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></div><div class="footer">© 2019 <a href="/" rel="nofollow">YuemingBi</a>. Powered by <a rel="nofollow" target="_blank" href="https://hexo.io">Hexo</a>. Theme <a target="_blank" href="https://github.com/lotabout/very-simple">very-simple</a>.</div></div></div></footer><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>