<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>记录学习点滴</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-18T05:02:06.284Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>YuemingBi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PCL-Learning-Notes</title>
    <link href="http://yoursite.com/2019/05/18/PCL-Learning-Notes/"/>
    <id>http://yoursite.com/2019/05/18/PCL-Learning-Notes/</id>
    <published>2019-05-18T02:12:22.000Z</published>
    <updated>2019-05-18T05:02:06.284Z</updated>
    
    <content type="html"><![CDATA[<font size="3">点云库(PCL:Point Cloud Library)学习笔记</font><p>1、了解名词<br>(1)点云：通过测量仪器得到的产品外观表面的点数据集合称之为点云，使用三维激光扫描仪或照相式扫描仪得到的点云，点数量比较大并且比较密集，叫密集点云。</p><p>点云是在和目标表面特性的海量点集合。<br>根据激光测量原理得到的点云，包括三维坐标(XYZ)和激光反射强度(Intensity)。<br>根据摄影测量原理得到的点云，包括三维坐标(XYZ)和颜色信息(RGB)。<br>结合激光测量和摄影测量原理得到点云，包括三维坐标(XYZ)、激光反射强度(Intensity)和颜色信息(RGB)。<br>在获取物体表面每个采样点的空间坐标后，得到的是一个点的集合，称之为“点云”(Point Cloud)。</p><p>当一束激光照射到物体表面时，所反射的激光会携带方位、距离等信息。若将激光束按照某种轨迹进行扫描，便会边扫描边记录到反射的激光点信息，由于扫描极为精细，则能够得到大量的激光点，因而就可形成激光点云。</p><p>(2)SLAM，即时定位与制图，包含3个关键词：实时、定位、制图，就是实时完成定位和制图的任务，这就是SLAM要解决的基本任务。按照使用的传感器分为<br>激光SLAM（LOAM、V-LOAM、cartographer）与视觉SLAM，其中视觉SLAM又可分为<br>单目SLAM（MonoSLAM、PTAM、DTAM、LSD-SLAM、ORB-SLAM（单目为主）、SVO）、双目SLAM（LIBVISO2、S-PTAM等）、<br>RGBD SLAM（KinectFusion、ElasticFusion、Kintinous、RGBD SLAM2、RTAB SLAM）；<br>视觉SLAM由前端（视觉里程计）、后端（位姿优化）、闭环检测、制图4个部分组成。</p><p>(3)Kinect RGB-D摄像机包含三个镜头，一个彩色摄像头，一个红外发射器和一个红外线CMOS摄像头。其中彩色摄像头可以获取彩色图像，红外线发射器和红外线CMOS摄像头共同组成了三维深度传感器。使用Kinect可以得到一副RGB图像和与之对应的深度图像，两种图像可以合成点云图。</p><p>2、kinect标定<br>视觉SLAM中通过相机模型来生成三维点云数据，需要对Kinect进行标定。Kinetc能同时获取彩色图像和深度图像，需要分别对两种图像进行标定。<br><img src="http://pqk5lbhsc.bkt.clouddn.com/pcl-1.png" alt="cmd-markdown-logo"><br><img src="http://pqk5lbhsc.bkt.clouddn.com/pcl-2.png" alt="cmd-markdown-logo"><br><img src="http://pqk5lbhsc.bkt.clouddn.com/pcl-3.png" alt="cmd-markdown-logo"></p><p>3、点线特征提取<br>(1)基于点线特征的三维地图构建算法主要包含三个模块：前端视觉里程计、后端优化和闭环优化。视觉里程计实时处理视频流，通过点线特征匹配求解相机的当前位姿；后端优化维护局部地图并对视觉里程计估计的初始位姿进行局部优化；闭环优化在检测到闭环后，通过闭环校正和全局优化得到全局一致的轨迹和地图。(视觉里程计：视觉里程计（VO），它根据相邻图像的信息粗略的估计出相机的运动，给后端提供较好的初始值。VO的实现方法可以根据是否需要提取特征分为两类：基于特征点的方法，不使用特征点的直接方法。 基于特征点的VO运行稳定，对光照、动态物体不敏感。)<br>(2)点特征提取<br>1)FAST特征点提取算法<br>FAST算法的思想很简单：如果一个像素与周围邻域的像素差别较大（过亮或者过暗），那么可以认为该像素是一个角点。和其他的特征点提取算法相比，FAST算法只需要比较像素和其邻域像素的灰度值大小，十分便捷。<br>FAST算法提取角点的步骤：</p><ul><li>在图像中选择像素p，假设其灰度值为：Ip</li><li>设置一个阈值T，例如：Ip的20%</li><li>选择p周围半径为3的圆上的16个像素，作为比较像素</li><li>假设选取的圆上有连续的N个像素大于Ip+T或者Ip−T，那么可以认为像素p就是一个特征点。（N通常取12，即为FAST-12；常用的还有FAST-9,FAST-11）。FAST算法只检测像素的灰度值，其运算速度极快，同时不可避免的也有一些缺点。</li><li>检测到的特征点过多并且会出现“扎堆”的现象。这可以在第一遍检测完成后，使用非最大值抑制（Non-maximal suppression），在一定区域内仅保留响应极大值的角点，避免角点集中的情况。</li><li>FAST提取到的角点没有方向和尺度信息。<br>2)BRIEF描述子<br>BRIEF是一种二进制的描述子，其描述向量是0和1表示的二进制串。0和1表示特征点邻域内两个像素（p和q）灰度值的大小：如果p比q大则选择1，反正就取0。在特征点的周围选择128对这样的p和q的像素对，就得到了128维由0，1组成的向量。那么p和q的像素对是怎么选择的呢？通常都是按照某种概率来随机的挑选像素对的位置。<br>BRIEF使用随机选点的比较，速度很快，而且使用二进制串表示最终生成的描述子向量，在存储以及用于匹配的比较时都是非常方便的，其和FAST的搭配起来可以组成非常快速的特征点提取和描述算法。<br>3)ORB算法<br>ORB是目前来说非常好的能够进行的实时的图像特征提取和描述的算法，它改进了FAST特征提取算法，并使用速度极快的二进制描述子BRIEF。针对FAST特征提取的算法的一些缺点，ORB也做了相应的改进。</li><li>使用非最大值抑制，在一定区域内仅仅保留响应极大值的角点，避免FAST提取到的角点过于集中。</li><li>FAST提取到的角点数量过多且不是很稳定，ORB中可以指定需要提取到的角点的数量N，然后对FAST提取到的角点分别计算Harris响应值，选择前N个具有最大响应值的角点作为最终提取到的特征点集合。</li><li>FAST提取到的角点不具有尺度信息，在ORB中使用图像金字塔，并且在每一层金字塔上检测角点，以此来保持尺度的不变性。</li><li><p>FAST提取到的角点不具有方向信息，在ORB中使用灰度质心法(Intensity Centroid)来保持特征的旋转不变性。<br>4)OpenCV3中特征点的提取和匹配<br>OpenCV中封装了常用的特征点算法（如SIFT,SURF，ORB等），提供了统一的接口，便于调用。 下面代码是OpenCV中使用其feature 2D 模块的示例代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Mat img1 = imread(&quot;F:\\image\\1.png&quot;);</span><br><span class="line">Mat img2 = imread(&quot;F:\\image\\2.png&quot;);</span><br><span class="line"></span><br><span class="line">// 1. 初始化</span><br><span class="line">vector&lt;KeyPoint&gt; keypoints1, keypoints2;</span><br><span class="line">Mat descriptors1, descriptors2;</span><br><span class="line">Ptr&lt;ORB&gt; orb = ORB::create();</span><br><span class="line"></span><br><span class="line">// 2. 提取特征点</span><br><span class="line">orb-&gt;detect(img1, keypoints1);</span><br><span class="line">orb-&gt;detect(img2, keypoints2);</span><br><span class="line"></span><br><span class="line">// 3. 计算特征描述符</span><br><span class="line">orb-&gt;compute(img1, keypoints1, descriptors1);</span><br><span class="line">orb-&gt;compute(img2, keypoints2, descriptors2);</span><br><span class="line">    </span><br><span class="line">// 4. 对两幅图像的BRIEF描述符进行匹配，使用BFMatch，Hamming距离作为参考</span><br><span class="line">vector&lt;DMatch&gt; matches;</span><br><span class="line">BFMatcher bfMatcher(NORM_HAMMING);</span><br><span class="line">bfMatcher.match(descriptors1, descriptors2, matches);</span><br></pre></td></tr></table></figure></li><li><p>在OpenCV3中重新的封装了特征提取的接口，可统一的使用Ptr<featuredetector> detector = FeatureDetector::create()来得到特征提取器的一个实例，所有的参数都提供了默认值，也可以根据具体的需要传入相应的参数。</featuredetector></p></li><li>在得到特征检测器的实例后，可调用的detect方法检测图像中的特征点的具体位置，检测的结果保存在vector<keypoint>向量中。</keypoint></li><li>有了特征点的位置后，调用compute方法来计算特征点的描述子，描述子通常是一个向量，保存在Mat中。</li><li><p>得到了描述子后，可调用匹配算法进行特征点的匹配。上面代码中，使用了opencv中封装后的暴力匹配算法BFMatcher，该算法在向量空间中，将特征点的描述子一一比较，选择距离（上面代码中使用的是Hamming距离）较小的一对作为匹配点。<br>上面代码匹配后的结果如下：<br><img src="http://pqk5lbhsc.bkt.clouddn.com/pcl-4.jpg" alt="cmd-markdown-logo"><br>特征点的匹配后的优化:<br>特征的匹配是针对特征描述子的进行的，上面提到特征描述子通常是一个向量，两个特征描述子的之间的距离可以反应出其相似的程度，也就是这两个特征点是不是同一个。根据描述子的不同，可以选择不同的距离度量。如果是浮点类型的描述子，可以使用其欧式距离；对于二进制的描述子（BRIEF）可以使用其汉明距离（两个不同二进制之间的汉明距离指的是两个二进制串不同位的个数）。<br>有了计算描述子相似度的方法，那么在特征点的集合中如何寻找和其最相似的特征点，这就是特征点的匹配了。最简单直观的方法就是上面使用的：暴力匹配方法(Brute-Froce Matcher)，计算某一个特征点描述子与其他所有特征点描述子之间的距离，然后将得到的距离进行排序，取距离最近的一个作为匹配点。这种方法简单粗暴，其结果也是显而易见的，通过上面的匹配结果，也可以看出有大量的错误匹配，这就需要使用一些机制来过滤掉错误的匹配。</p></li><li><p>汉明距离小于最小距离的两倍:选择已经匹配的点对的汉明距离小于最小距离的两倍作为判断依据，如果小于该值则认为是一个错误的匹配，过滤掉；大于该值则认为是一个正确的匹配。其实现代码也很简单，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 匹配对筛选</span><br><span class="line">double min_dist = 1000, max_dist = 0;</span><br><span class="line">// 找出所有匹配之间的最大值和最小值</span><br><span class="line">for (int i = 0; i &lt; descriptors1.rows; i++)</span><br><span class="line">&#123;</span><br><span class="line">double dist = matches[i].distance;</span><br><span class="line">    if (dist &lt; min_dist) min_dist = dist;</span><br><span class="line">    if (dist &gt; max_dist) max_dist = dist;</span><br><span class="line">&#125;</span><br><span class="line">// 当描述子之间的匹配大于2倍的最小距离时，即认为该匹配是一个错误的匹配。</span><br><span class="line">// 但有时描述子之间的最小距离非常小，可以设置一个经验值作为下限</span><br><span class="line">vector&lt;DMatch&gt; good_matches;</span><br><span class="line">for (int i = 0; i &lt; descriptors1.rows; i++)</span><br><span class="line">&#123;</span><br><span class="line">    if (matches[i].distance &lt;= max(2 * min_dist, 30.0))</span><br><span class="line">    good_matches.push_back(matches[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>结果如下：<br><img src="http://pqk5lbhsc.bkt.clouddn.com/pcl-5.jpg" alt="cmd-markdown-logo"><br>对比只是用暴力匹配的方法，进行过滤后的匹配效果好了很多。</p><ul><li>交叉匹配<br>针对暴力匹配，可以使用交叉匹配的方法来过滤错误的匹配。交叉过滤的是想很简单，再进行一次匹配，反过来使用被匹配到的点进行匹配，如果匹配到的仍然是第一次匹配的点的话，就认为这是一个正确的匹配。举例来说就是，假如第一次特征点A使用暴力匹配的方法，匹配到的特征点是特征点B；反过来，使用特征点B进行匹配，如果匹配到的仍然是特征点A，则就认为这是一个正确的匹配，否则就是一个错误的匹配。OpenCV中BFMatcher已经封装了该方法，创建BFMatcher的实例时，第二个参数传入true即可，BFMatcher bfMatcher(NORM_HAMMING,true)。</li><li>KNN匹配<br>K近邻匹配，在匹配的时候选择K个和特征点最相似的点，如果这K个点之间的区别足够大，则选择最相似的那个点作为匹配点，通常选择K = 2，也就是最近邻匹配。对每个匹配返回两个最近邻的匹配，如果第一匹配和第二匹配距离比率足够大（向量距离足够远），则认为这是一个正确的匹配，比率的阈值通常在2左右。OpenCV中的匹配器中封装了该方法，上面的代码可以调用bfMatcher-&gt;knnMatch(descriptors1, descriptors2, knnMatches, 2);具体实现的代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const float minRatio = 1.f / 1.5f;</span><br><span class="line">const int k = 2;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;DMatch&gt;&gt; knnMatches;</span><br><span class="line">matcher-&gt;knnMatch(leftPattern-&gt;descriptors, rightPattern-&gt;descriptors, knnMatches, k);</span><br><span class="line"></span><br><span class="line">for (size_t i = 0; i &lt; knnMatches.size(); i++) &#123;</span><br><span class="line">const DMatch&amp; bestMatch = knnMatches[i][0];</span><br><span class="line">const DMatch&amp; betterMatch = knnMatches[i][1];</span><br><span class="line"></span><br><span class="line">float  distanceRatio = bestMatch.distance / betterMatch.distance;</span><br><span class="line">if (distanceRatio &lt; minRatio)</span><br><span class="line">            matches.push_back(bestMatch);</span><br><span class="line">&#125;const  float minRatio =  1.f  /  1.5f;</span><br><span class="line">const  int k =  2;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;DMatch&gt;&gt; knnMatches;</span><br><span class="line">matcher-&gt;knnMatch(leftPattern-&gt;descriptors, rightPattern-&gt;descriptors, knnMatches, 2);</span><br><span class="line"></span><br><span class="line">for (size_t i =  0; i &lt; knnMatches.size(); i++) &#123;</span><br><span class="line">    const DMatch&amp; bestMatch = knnMatches[i][0];</span><br><span class="line">    const DMatch&amp; betterMatch = knnMatches[i][1];</span><br><span class="line">    float distanceRatio = bestMatch.distance  / betterMatch.distance;</span><br><span class="line">    if (distanceRatio &lt; minRatio)</span><br><span class="line">            matches.push_back(bestMatch);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p>将不满足的最近邻的匹配之间距离比率大于设定的阈值（1/1.5）匹配剔除。</p><ul><li>RANSAC:另外还可采用随机采样一致性（RANSAC）来过滤掉错误的匹配，该方法利用匹配点计算两个图像之间单应矩阵，然后利用重投影误差来判定某一个匹配是不是正确的匹配。OpenCV中封装了求解单应矩阵的方法findHomography,可以为该方法设定一个重投影误差的阈值，可以得到一个向量mask来指定那些是符合该重投影误差的匹配点对，以此来剔除错误的匹配，代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">const int minNumbermatchesAllowed = 8;</span><br><span class="line">if (matches.size() &lt; minNumbermatchesAllowed)</span><br><span class="line">    return;</span><br><span class="line"></span><br><span class="line">//Prepare data for findHomography</span><br><span class="line">vector&lt;Point2f&gt; srcPoints(matches.size());</span><br><span class="line">vector&lt;Point2f&gt; dstPoints(matches.size());</span><br><span class="line"></span><br><span class="line">for (size_t i = 0; i &lt; matches.size(); i++) &#123;</span><br><span class="line">    srcPoints[i] = rightPattern-&gt;keypoints[matches[i].trainIdx].pt;</span><br><span class="line">    dstPoints[i] = leftPattern-&gt;keypoints[matches[i].queryIdx].pt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//find homography matrix and get inliers mask</span><br><span class="line">vector&lt;uchar&gt; inliersMask(srcPoints.size());</span><br><span class="line">homography = findHomography(srcPoints, dstPoints, CV_FM_RANSAC, reprojectionThreshold, inliersMask);</span><br><span class="line"></span><br><span class="line">vector&lt;DMatch&gt; inliers;</span><br><span class="line">for (size_t i = 0; i &lt; inliersMask.size(); i++)&#123;</span><br><span class="line">    if (inliersMask[i])</span><br><span class="line">        inliers.push_back(matches[i]);</span><br><span class="line">&#125;</span><br><span class="line">matches.swap(inliers);const  int minNumbermatchesAllowed =  8;</span><br><span class="line">if (matches.size() &lt; minNumbermatchesAllowed)</span><br><span class="line">    return;</span><br><span class="line"></span><br><span class="line">//Prepare data for findHomography</span><br><span class="line">vector&lt;Point2f&gt;  srcPoints(matches.size());</span><br><span class="line">vector&lt;Point2f&gt;  dstPoints(matches.size());</span><br><span class="line"></span><br><span class="line">for (size_t i =  0; i &lt; matches.size(); i++) &#123;</span><br><span class="line">    srcPoints[i] = rightPattern-&gt;keypoints[matches[i].trainIdx].pt;</span><br><span class="line">    dstPoints[i] = leftPattern-&gt;keypoints[matches[i].queryIdx].pt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//find homography matrix and get inliers mask</span><br><span class="line">vector&lt;uchar&gt;  inliersMask(srcPoints.size());</span><br><span class="line">homography =  findHomography(srcPoints, dstPoints, CV_FM_RANSAC, reprojectionThreshold, inliersMask);</span><br><span class="line"></span><br><span class="line">vector&lt;DMatch&gt; inliers;</span><br><span class="line">for (size_t i =  0; i &lt; inliersMask.size(); i++)&#123;</span><br><span class="line">    if (inliersMask[i])</span><br><span class="line">        inliers.push_back(matches[i]);</span><br><span class="line">&#125;</span><br><span class="line">matches.swap(inliers);</span><br></pre></td></tr></table></figure></li></ul><p>(3)线特征提取</p><p>4、前端视觉里程计位姿估计</p><p>5、后端优化<br>视觉里程计能够增量式地构建环境地图，但其只考虑相邻之间位姿关系，长时间运行不可避免会产生累计误差，这样得到的地图是不准确的。后端优化环节把当前帧与更早的帧关联起来，加入更多的地图数据进行优化，从而降低累计误差。<br>视觉SLAM中会有成千上万帧图像，后端优化并不会耗费巨大的计算量将每一帧都纳入优化，因此需要选择一些有代表性的帧作为关键帧。同时，为了便于后续跟踪，需要尽可能快速插入关键帧。</p><p>6、八叉树地图的构建<br>点云地图是一种较为初级的地图表达方式，不能直接用于机器人的导航。八叉树地图中的每个节点表示一个立方体所包含的空间，通常称为体素。这个立方体递归地细分为八个子立方体，直到分割成最小的体素。最小体素的大小决定了八叉树的分辨率，由于八叉树是一种分层数据结构，能够在任意层次切割得到不同分辨率的表达。八叉树在不同分辨率下的表示如图：<br><img src="http://pqk5lbhsc.bkt.clouddn.com/pcl-6.png" alt="cmd-markdown-logo"><br><img src="http://pqk5lbhsc.bkt.clouddn.com/pcl-7.png" alt="cmd-markdown-logo"><br><img src="http://pqk5lbhsc.bkt.clouddn.com/pcl-8.png" alt="cmd-markdown-logo"><br>由八叉树的表达方式可以看出，其优点在于：<br>(1)压缩空间：八叉树的节点存储了是否被占据的信息，当节点的所有子节点全部被占据或是全不占据时，就无需展开此节点，能够大大节省内存空间。<br>(2)更新地图：通过概率对数可以方便的对八叉树地图进行更新。<br>(3)导航与避障：八叉树地图每个体素表示其被占据的概率，机器人可以很方便地对八叉树地图进行空间可行性分析和路径规划。并且八叉树地图分辨率可调，可以灵活地将不同分辨率的地图应用于不同层次的导航。<br><img src="http://pqk5lbhsc.bkt.clouddn.com/pcl-9.png" alt="cmd-markdown-logo"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font size=&quot;3&quot;&gt;点云库(PCL:Point Cloud Library)学习笔记&lt;/font&gt;

&lt;p&gt;1、了解名词&lt;br&gt;(1)点云：通过测量仪器得到的产品外观表面的点数据集合称之为点云，使用三维激光扫描仪或照相式扫描仪得到的点云，点数量比较大并且比较密集，叫密集
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Turtlebot2 rgbslam_v2 三维地图建模</title>
    <link href="http://yoursite.com/2019/05/18/Turtlebot2-rgbslam-3D-Mapping/"/>
    <id>http://yoursite.com/2019/05/18/Turtlebot2-rgbslam-3D-Mapping/</id>
    <published>2019-05-18T01:36:29.000Z</published>
    <updated>2019-05-18T02:08:49.904Z</updated>
    
    <content type="html"><![CDATA[<p><font size="3">Turtlebot2 rgbslam_v2 三维地图建模</font><br>此篇文章转载博客:<code>www.guyuehome.com/860</code><br>1、启动UI<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">roslaunch freenect_launch freenect.launch</span><br><span class="line">roslaunch rgbdslam rgbdslam.launch</span><br></pre></td></tr></table></figure></p><p>或者：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ roslaunch rgbdslam openni+rgbdslam.launch(启动界面)</span><br></pre></td></tr></table></figure></p><p><img src="http://pqk5lbhsc.bkt.clouddn.com/3D-mapping-1.png" alt="cmd-markdown-logo"><br>2、启动底座和遥控<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ roslaunch turtlebot_bringup minimal.launch(启动底座)</span><br><span class="line">$ roslaunch turtlebot_teleop keyboard_teleop.launch(启动遥控)</span><br></pre></td></tr></table></figure></p><p>3、建立地图<br>按下rgbd-slam-v2的空白键，让机器人四处走起来。UI的状态栏会显示程序的运行状态，有提取特征、加入新Frame，等等。如果它成功匹配上，上图的点云就会更新，并且会跟着机器人转动。<br><img src="http://pqk5lbhsc.bkt.clouddn.com/3D-mapping-2.png" alt="cmd-markdown-logo"><br>别看上面像是打了码一样的，最后出的点云图可是高清无码的。<br>4、保存地图<br>建模完成后，直接在菜单栏中选择保存成点云数据即可。<br>5、查看地图<br>然可以通过pcl_ros（<a href="http://wiki.ros.org/pcl_ros" target="_blank" rel="noopener">http://wiki.ros.org/pcl_ros</a> ）来查看保存的点云地图：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun pcl_ros pcd_to_pointcloud quicksave.pcd</span><br></pre></td></tr></table></figure></p><p>在rviz中显示pointcloud2数据：<br><img src="http://pqk5lbhsc.bkt.clouddn.com/3D-mapping-3.jpg" alt="cmd-markdown-logo"><br>6、总结<br>Rgbd-slam-v2是14年论文里提到的算法。它整合了SLAM领域里的各种技术：图像特征、回环检测、点云、图优化等等，是一个非常全面且优秀的程序。它的UI做的也很漂亮，可以在它的源代码上继续开发。<br>缺点：在美观之外，由于要提特征（SIFT很费时）、渲染点云，这些事情是很吃资源的，导致算法实时性不太好。有时会发现它卡在那儿不动了，不得不等它一小会。机器人如果走的太快，很容易跟丢。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;font size=&quot;3&quot;&gt;Turtlebot2 rgbslam_v2 三维地图建模&lt;/font&gt;&lt;br&gt;此篇文章转载博客:&lt;code&gt;www.guyuehome.com/860&lt;/code&gt;&lt;br&gt;1、启动UI&lt;br&gt;&lt;figure class=&quot;highlight p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Turtlebot2 rgbdslam_v2环境配置以及三位地图建模</title>
    <link href="http://yoursite.com/2019/05/18/Turtlebot2-rgbdslam-Environment/"/>
    <id>http://yoursite.com/2019/05/18/Turtlebot2-rgbdslam-Environment/</id>
    <published>2019-05-17T23:31:00.000Z</published>
    <updated>2019-05-18T02:09:59.368Z</updated>
    
    <content type="html"><![CDATA[<font size="3">Turtlebot2 rgbdslam_v2环境配置以及三位地图建模</font><p>1、创建一个工作空间，编译一遍<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p ~/catkin_ws/src</span><br><span class="line">$ cd ~/catkin_ws</span><br><span class="line">$ catkin_make</span><br></pre></td></tr></table></figure></p><p>2、下载rgbdslam_v2代码包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/catkin_ws/src</span><br><span class="line">$ wget -q http://github.com/felixendres/rgbdslam_v2/archive/kinetic.zip</span><br><span class="line">$ unzip kinetic.zip</span><br><span class="line">(把解压出来的文件名更改为rgbdslam_v2)</span><br><span class="line">$ sudo cp -a ~/catkin_ws/src/rgbdslam_v2 /opt/ros/kinetic/share</span><br></pre></td></tr></table></figure></p><p>3、安装g2o的依赖<br>sudo apt-get install libsuitesparse-dev<br>4、创建eigen工作空间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ~/src</span><br><span class="line">$ cd ~/src</span><br><span class="line">$ wget http://bitbucket.org/eigen/eigen/get/3.2.10.tar.bz2</span><br><span class="line">mkdir eigen</span><br><span class="line">$ tar -xvjf 3.2.10.tar.bz2 -C eigen --strip-components 1</span><br></pre></td></tr></table></figure></p><p>5、创建g2o工作空间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/src</span><br><span class="line">$ git clone https://github.com/felixendres/g2o.git</span><br><span class="line">$ cd ~/src/g2o</span><br><span class="line">$ mkdir ~/src/g2o/build</span><br><span class="line">$ cd ~/src/g2o/build</span><br></pre></td></tr></table></figure></p><p>6、配置g2o代码包中的CMakeLists.txt文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ vi ~/src/g2o/CMakeLists.txt</span><br><span class="line">(如果不习惯vi 可以执行 sudo gedit ~/src/g2o/CMakeLists.txt</span><br><span class="line"> 也可以使用atom文本编辑器打开)</span><br><span class="line">在251行中：</span><br><span class="line">将SET(G2O_EIGEN3_INCLUDE $&#123;EIGEN3_INCLUDE_DIR&#125; CACHE PATH &quot;Directory of Eigen3&quot;)</span><br><span class="line">替换为SET(G2O_EIGEN3_INCLUDE &quot;~/src/eigen&quot; CACHE PATH &quot;Directory of Eigen3&quot;)</span><br><span class="line">保存退出</span><br></pre></td></tr></table></figure></p><p>7、编译g2o工作空间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/src/g2o/build</span><br><span class="line">$ cmake ../</span><br><span class="line">$ make</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure></p><p>8、下载PCL1.8(点云库：Point Cloud Library)<br>在此过程中，采用了很多方法，但都失败了，最后直接找到源代码的位置，下载zip文件(tar文件无法下载),下载之后放在~/src目录下解压。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/src</span><br><span class="line">$ unzip pcl-pcl-1.8.0.zip</span><br></pre></td></tr></table></figure></p><p>9、配置PCL,使其支持C++2011<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/src/pcl-pcl-1.8.0</span><br><span class="line">$ vi CMakeLists.txt(或者sudo gedit CMakeLists.txt)</span><br><span class="line">在146行(endif()下一行)中加入SET(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++11&quot;)</span><br></pre></td></tr></table></figure></p><p>10、编译PCL<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/src/pcl-pcl-1.8.0</span><br><span class="line">$ mkdir build</span><br><span class="line">$ cd build</span><br><span class="line">$ cmake ../</span><br><span class="line">$ make VERBOSE=1 (此步骤是为了验证PCL是否支持C++2011，如果能在输出中看到&quot;-std=c++11&quot;，则说明是支持的，没有问题,按Ctrl+C退出，执行下一行命令。)</span><br><span class="line">$ make</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure></p><p>11、配置rgbdslam_v2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/catkin_ws/src/rgbdslam_v2</span><br><span class="line">$ vi CMakeLists.txt(sudo gedit CMakeLists.txt)</span><br><span class="line">在第六行中加入:add_compile_options(-std=c++11)</span><br><span class="line">之后将find_package(PCL 1.7 REQUIRED COMPONENTS common io)</span><br><span class="line">替换为:</span><br><span class="line">find_package(PCL 1.8 REQUIRED COMPONENTS common io)</span><br></pre></td></tr></table></figure></p><p>12、编译rgbdslam_v2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/catkin_ws</span><br><span class="line">$ source devel/setup.bash</span><br><span class="line">$ cd ~/catkin_ws/src/rgbdslam_v2</span><br><span class="line">$ catkin_make</span><br><span class="line">$ source devel/setup.bash</span><br><span class="line">$ echo &quot;source ~/catkin_ws/devel/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure></p><p>13、环境测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ roslaunch freenect_launch freenect.launch</span><br><span class="line">(或者输入:roslaunch openni_launch openni.launch,如果没有设备连接，会显示&quot;waiting for devices to be connected&quot;)</span><br><span class="line">$ roslaunch rgbdslam openni+rgbdslam.launch(运行此命令就可以看到一个UI的界面了)</span><br></pre></td></tr></table></figure></p><p>14、查看地图<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rosrun pcl_ros pcd_to_pointcloud quicksave.pcd</span><br></pre></td></tr></table></figure></p><p>有关博客参考：<br><code>https://hubpages.com/technology/Instructions-for-compiling-rgbdslam-v2-on-a-fresh-Ubuntu-1604-install-ros-kinetic-in-virtualbox</code><br><code>https://blog.csdn.net/u011178262/article/details/83046256</code><br><code>https://blog.csdn.net/yangtze_1006/article/details/51606680</code><br><code>www.guyuehome.com/860</code><br><code>https://www.cnblogs.com/gaoxiang12/p/4462518.html</code><br><code>https://github.com/felixendres/rgbdslam_v2</code><br><code>https://www.ncnynl.com/archives/201708/1931.html</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font size=&quot;3&quot;&gt;Turtlebot2 rgbdslam_v2环境配置以及三位地图建模&lt;/font&gt;

&lt;p&gt;1、创建一个工作空间，编译一遍&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>turtlebot2-kinetic环境配置</title>
    <link href="http://yoursite.com/2019/05/16/Turtlebot2-Kinetic-Environment/"/>
    <id>http://yoursite.com/2019/05/16/Turtlebot2-Kinetic-Environment/</id>
    <published>2019-05-16T11:08:25.000Z</published>
    <updated>2019-05-16T11:50:40.463Z</updated>
    
    <content type="html"><![CDATA[<font size="3">Turtlebot2-kinetic环境配置</font><p>•安装准备<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install python-rosdep python-wstool ros-kinetic-ros</span><br><span class="line">$ sudo apt-get install pyqt5-dev-tools</span><br><span class="line">$ sudo rosdep init</span><br><span class="line">$ rosdep update</span><br></pre></td></tr></table></figure></p><p>•分别建立三个工作空间rocon，kobuki，turtlebot，下载和编译源码<br>•建立rocon目录，下载和编译，rocon都有对应的kinetic版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ~/rocon</span><br><span class="line">$ cd ~/rocon</span><br><span class="line">$ wstool init -j4 src https://raw.github.com/robotics-in-concert/rocon/release/kinetic/rocon.rosinstall</span><br><span class="line">（注意：如该下载失败，到github中找到相应文件进行配置）</span><br><span class="line">$ source /opt/ros/kinetic/setup.bash</span><br><span class="line">$ rosdep install --from-paths src -i -y</span><br><span class="line">$ catkin_make</span><br></pre></td></tr></table></figure></p><p>•建立kobuki目录，下载和编译.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ~/kobuki</span><br><span class="line">$ cd ~/kobuki</span><br><span class="line">$ wstool init -j4 src https://raw.githubusercontent.com/yujinrobot/yujin_tools/kinetic-devel/rosinstalls/kinetic/kobuki.rosinstall</span><br><span class="line">$ source ~/rocon/devel/setup.bash</span><br><span class="line">$ rosdep install --from-paths src -i -y</span><br><span class="line">$ catkin_make</span><br></pre></td></tr></table></figure></p><p>•建立turtlebot目录，下载和编译.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ~/turtlebot</span><br><span class="line">$ cd ~/turtlebot</span><br><span class="line">$ wstool init -j4 src https://raw.github.com/yujinrobot/yujin_tools/kinetic-devel/rosinstalls/kinetic/turtlebot.rosinstall</span><br><span class="line">$ source ~/kobuki/devel/setup.bash</span><br><span class="line">$ rosdep install --from-paths src -i -y</span><br><span class="line">$ catkin_make</span><br></pre></td></tr></table></figure></p><p>•添加工作空间到bashrc文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;source ~/rocon/devel/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">$ echo &quot;source ~/kobuki/devel/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">$ echo &quot;source ~/turtlebot/devel/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure></p><p>•启用新环境：<br><code>$ source ~/.bashrc</code><br>•测试环境生效：<br><code>$ roscd turtlebot</code><br>能正常进入到目录就说明成功</p><p>•生成kobuki别名<br><code>$ rosrun kobuki_ftdi create_udev_rules</code></p><p>•安装kinect驱动<br><code>$ sudo apt-get install ros-kinetic-openni-* ros-kinetic-openni2-* ros-kinetic-freenect-*</code></p><p><font size="3">Turtlebot-kinetic测试</font><br>测试Turtlebot安装（Turtlebot和工作站）</p><p>在工控机中，新开终端输入<br><code>$ roscore</code><br>如果ROS安装正确显示<br><code>$ started core service [/rosout]</code></p><p>如有问题，请检查安装步骤！<br>检查别名：<br> •输入检测命令：<br><code>$ ls /dev/kobuki</code><br> •会显示有对应的设备/dev/kobuki<br> •如果没有，添加别名：<br><code>$ rosrun kobuki_ftdi create_udev_rules</code><br> •重插USB线，在进行上述的检测命令</p><p> •通过遥控移动（仅TurtleBot，通过Turtlebot的上网本操作）<br> 1.打开Turtlebot开关，状态点亮。<br> 2.启动Turtlebot，在上网本，打开一个新终端，运行如下命令：<br><code>$ roslaunch turtlebot_bringup minimal.launch</code><br> 3.启动键盘遥控，在上网本，打开另一个新终端，运行如下命令：<br><code>$ roslaunch turtlebot_teleop keyboard_teleop.launch</code><br> 4.点击键盘“i”前进。</p><p>通过发布主题命令<br> •命令：<br><code>$ rostopic pub -r 10 /cmd_vel_mux/input/navi  geometry_msgs/Twist  &#39;{linear:  {x: 0.1, y: 0.0, z: 0.0}, angular: {x: 0.0,y: 0.0,z: 0.0}}&#39;</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font size=&quot;3&quot;&gt;Turtlebot2-kinetic环境配置&lt;/font&gt;

&lt;p&gt;•安装准备&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;li
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>turtlebot2-indigo环境配置</title>
    <link href="http://yoursite.com/2019/05/16/turtlebot2-Indigo-Environment/"/>
    <id>http://yoursite.com/2019/05/16/turtlebot2-Indigo-Environment/</id>
    <published>2019-05-16T11:08:05.000Z</published>
    <updated>2019-05-16T11:50:38.361Z</updated>
    
    <content type="html"><![CDATA[<font size="3">Turtlebot2-indigo环境配置</font><p>安装步骤<br>    有两种安装方法，一种直接的安装命令，另外一种源码编译安装，区别在于：直接安装命令是安装在电脑默认路径/opt/ros/indigo/share里面不便于更改代码，因为默认路径下文件一般有访问权限，无法直接更改，需要使用sudo chmod -R 777 /opt更改其权限，使得每个使用的人都可以更改；源码编译，安装的文件在Home主目录中,方便更改。</p><p>1、直接安装命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install ros-indigo-turtlebot ros-indigo-turtlebot-apps ros-indigo-turtlebot-interactions ros-indigo-turtlebot-simulator ros-indigo-kobuki-ftdi ros-indigo-rocon-remocon ros-indigo-rocon-qt-library ros-indigo-ar-track-alvar-msgs</span><br></pre></td></tr></table></figure></p><p>2、源码方式安装<br> 1)先安装依赖项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install python-rosdep python-wstool ros-indigo-ros</span><br><span class="line">$ sudo rosdep init</span><br><span class="line">$ rosdep update</span><br></pre></td></tr></table></figure></p><p> 2)建立Turtlebot工作空间</p><p>#创建三个文件夹，分别存放rocon、kobuki、turtlebot，复制相应的代码、设置文件所在路径工作环境、编译<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ~/rocon</span><br><span class="line">$ cd ~/rocon</span><br><span class="line">$ wstool init -j5 src https://raw.github.com/robotics-in-concert/rocon/release/indigo/rocon.rosinstall</span><br><span class="line">$ source /opt/ros/indigo/setup.bash</span><br><span class="line">$ rosdep install --from-paths src -i -y</span><br><span class="line">$ catkin_make</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ~/kobuki</span><br><span class="line">$ cd ~/kobuki</span><br><span class="line">$ wstool init src -j5 https://raw.github.com/yujinrobot/yujin_tools/master/rosinstalls/indigo/kobuki.rosinstall</span><br><span class="line">$ source ~/rocon/devel/setup.bash</span><br><span class="line">$ rosdep install --from-paths src -i -y</span><br><span class="line">$ catkin_make</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ~/turtlebot</span><br><span class="line">$ cd ~/turtlebot</span><br><span class="line">$ wstool init src -j5 https://raw.github.com/yujinrobot/yujin_tools/master/rosinstalls/indigo/turtlebot.rosinstall</span><br><span class="line">$ source ~/kobuki/devel/setup.bash</span><br><span class="line">$ rosdep install --from-paths src -i -y</span><br><span class="line">$ catkin_make</span><br></pre></td></tr></table></figure><p>安装完成后，测试命令：<br><code>$ roslaunch turtlebot_bringup minimal.launch</code><br>如果正常可以看到以下界面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">... logging to /home/fjx/.ros/log/e9549e36-850f-11e8-ab48-543530c06929/roslaunch-giimbot-19656.log</span><br><span class="line">Checking log directory for disk usage. This may take awhile.</span><br><span class="line">Press Ctrl-C to interrupt</span><br><span class="line">Done checking log file disk usage. Usage is &lt;1GB.</span><br><span class="line">started roslaunch server http://giimbot:36504/</span><br><span class="line">SUMMARY</span><br><span class="line">========</span><br><span class="line">PARAMETERS</span><br><span class="line"> * /app_manager/auto_rapp_installation: False</span><br><span class="line"> * /app_manager/auto_start_rapp:</span><br><span class="line"> ...........(中间省略)</span><br><span class="line">process[interactions-12]: started with pid [19769]</span><br><span class="line">process[zeroconf/zeroconf-13]: started with pid [19781]</span><br><span class="line">[ INFO] [1531316403.920700304]: Zeroconf: service successfully established [turtlebot][_ros-master._tcp][11311]</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font size=&quot;3&quot;&gt;Turtlebot2-indigo环境配置&lt;/font&gt;


&lt;p&gt;安装步骤&lt;br&gt;    有两种安装方法，一种直接的安装命令，另外一种源码编译安装，区别在于：直接安装命令是安装在电脑默认路径/opt/ros/indigo/share里面不便于更改代
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>基于legacy引导方式的win7-linux双系统</title>
    <link href="http://yoursite.com/2019/04/29/%E5%9F%BA%E4%BA%8Elegacy%E5%BC%95%E5%AF%BC%E6%96%B9%E5%BC%8F%E7%9A%84win7-linux%E5%8F%8C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2019/04/29/基于legacy引导方式的win7-linux双系统/</id>
    <published>2019-04-29T13:34:57.000Z</published>
    <updated>2019-04-30T09:21:50.609Z</updated>
    
    <content type="html"><![CDATA[<p>写到这篇文章，笔者还是很有感触，因为我在大一的时候给电脑装双系统，用的是上一篇文章win10-linux的常规方法，也是用U盘作为启动项，但死活就是安装不上。之后才发现原因，我电脑的win7系统的引导方式是legacy，而常规方法安装的linux系统恰好是uefi引导方式，硬装是装不上的。如果你的电脑也是legacy引导方式想装双系统，其实很简单，这篇文章就可以解决你的问题。</p><p><strong><font size="3">操作步骤</font></strong></p><p> (1)准备两个东西：<br>    1) ubuntu镜像文件，网上自行下载(最好是到官网上去下载，靠谱)，这里以ubuntu16.04为例。<br>    2) EasyBCD软件，网上自行下载(最好是安装版，不要绿色版)。</p><p> (2)分区。计算机右键-管理-磁盘管理，选中一个磁盘(这里以D盘为例)右键磁盘压缩，压缩空间自己定，这个空间就是给linux系统，最好不要小于20G。<br><img src="http://pqk5lbhsc.bkt.clouddn.com/ubuntu1-1.png" alt="cmd-markdown-logo"></p><p> (3)打开EasyBCD软件，添加linux引导项。<br><img src="http://pqk5lbhsc.bkt.clouddn.com/ubuntu1-2.png" alt="cmd-markdown-logo"></p><p> (4)安装之后，点击配置，进行文件配置，然后就会出现一个menu.lst文件，我们要编辑这个文件 因为系统就是这个文件找到我们的Ubuntu的。<br><img src="http://pqk5lbhsc.bkt.clouddn.com/ubuntu1-3.png" alt="cmd-markdown-logo"></p><p><img src="http://pqk5lbhsc.bkt.clouddn.com/ubuntu1-4.png" alt="cmd-markdown-logo"></p><p>把下面的 英文 复制进去，把原来的全覆盖掉<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title Install Ubuntu</span><br><span class="line">root (hd0,0)</span><br><span class="line">kernel (hd0,0)/vmlinuz.efi boot=casper iso-scan/filename=/ubuntu-16.04.2-desktop-amd64.iso ro quiet splash locale=zh_CN.UTF-8</span><br><span class="line">initrd (hd0,0)/initrd.lz</span><br></pre></td></tr></table></figure></p><p> 特别注意:<br>  1)上图代码中”ubuntu-16.04.2-desktop-amd64.iso”是你下载ubuntu系统文件名，这个文件名是可以修改的，但修改的名字一定要与写入的代码名字一致，否则将无法安装。<br>  2)在64位中casper目录下为vmlinuz.efi，32位的才是vmlinuz（本人亲测，在安装过程中碰到error 15 file not find 错误，就是因为这个问题）<br>  3)对于有的电脑上你的第一个盘符并不是C盘，在磁盘管理中可以看出，所以安装时需将(hd0,0)改为（hd0,1）(假设为第二个)。</p><p> (5)ubuntu-16.04.2-desktop-amd64.iso镜像文件用压缩软件或者虚拟光驱打开，找到casper文件夹，把里面的initrd.lz和vmlinuz.efi解压到C盘，把.disk文件夹也解压到C盘，然后在把ubuntu-16.04.2-desktop-amd64.iso文件也复制到C盘。当然你也可以将这三个文件复制到别的盘符，但一定要与代码中的盘符相对应。比如我想在把文件复制到D盘，则代码中要将(hd0,0)改为相应D盘的盘符(hd0,1)。</p><p> (6)重启，就会看到有2个启动菜单，我们选择NeoGrub引导加载器，过一会就出现ubuntu系统的界面。</p><p> (7)有的电脑是双显卡，重启可能会在出现ubuntu图标时卡住(如果没卡请忽略)，这时因为独立显卡的问题，需要把它禁用掉，重启到win7系统，将EasyBCD配置文件改为如下：<br><img src="http://pqk5lbhsc.bkt.clouddn.com/ubuntu1-5.png" alt="cmd-markdown-logo"><br> 然后再重启，加载引导就可以进入ubuntu界面了。</p><p> (8)这个步骤非常重要，出现界面之后，不要着急点安装，按Ctrl+Alt+t打开终端，输入代码:sudo umount -l /isodevice这一命令取消掉对光盘所在驱动器的挂载(注意，这里的-l是-L的小写，-l与/isodevice之间有一个空格)，否则分区界面找不到分区。</p><p> (9)然后点击ubuntu桌面的”install ubuntu”进入安装，在进行到“安装类型”的时候，我们可以选择“安装ubuntu，与Windows7共存”，这样就可以不用自己分区，非常简便，我们也可以选择“其它选项”，这样就需要自己来分区(此处不详细讲解)，其他的安装步骤正常安装即可。安装完成后，如果刚才(7)界面卡住，先不要重启，因为新系统没有配置Grub文件，重启还会卡住。此时要按Ctrl+Alt+T打开终端，输入sudo gedit /boot/grub.cfg 在出现的文档中搜索splash，并在其后加一个空格然后输入nomodeset并保存文档，就OK了。</p><p> (10)重启，就可以看见粉色的引导界面，有“ubunut”和“windows7”(win7在最下面)，这就是ubuntu引导带着win7一起启动，至此双系统安装成功。</p><p> (11)进入ubuntu系统后，按Ctrl+Alt+t打开终端，输入”sudo mv /et/grub.d/30_os-prober /etc/grub.d/06_os-prober”然后输入密码回车，再输入”sudo update-grub”,输入密码回车，此时，win7系统引导就在最上面了，每次开机就默认进入win7系统。</p><p> (12)重启进入win7，打开EasyBCD，移除nerogrub引导项(此步骤不做也可，没有什么影响)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写到这篇文章，笔者还是很有感触，因为我在大一的时候给电脑装双系统，用的是上一篇文章win10-linux的常规方法，也是用U盘作为启动项，但死活就是安装不上。之后才发现原因，我电脑的win7系统的引导方式是legacy，而常规方法安装的linux系统恰好是uefi引导方式，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>基于uefi引导方式的win10-linux双系统</title>
    <link href="http://yoursite.com/2019/04/28/%E5%9F%BA%E4%BA%8Euefi%E5%BC%95%E5%AF%BC%E6%96%B9%E5%BC%8F%E7%9A%84win10-linux%E5%8F%8C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2019/04/28/基于uefi引导方式的win10-linux双系统/</id>
    <published>2019-04-28T13:36:00.000Z</published>
    <updated>2019-04-30T09:23:17.450Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章是装win10-linux双系统最基本的方法，如果你的电脑是uefi引导的win10系统，这个方法可行。但是强调一点，如果是弘基电脑，那么请您绕行，对于弘基电脑来说，这种方法是不可行的。本人装过弘基电脑的双系统，但是装完之后会发现直接进入win10系统，没有linux的引导，还需要在win10系统中用EasyUEFI这个软件来手动添加linux引导项，非常的麻烦，之后还会有许多的bug，需要不定期的进行维护。本人也请教过专业人士，但也没有办法，弘基电脑就是只能这样。下面进入正题，常规方法安装双系统。</p><p><strong><font size="4">操作步骤</font></strong></p><p> (1)准备三个东西：<br>    1)ubuntuIOS镜像文件，网上自行下载(建议到官网下载，靠谱)<br>    2)刻录软件，这里用的是rufus<br>    3)U盘，最好不小于4G</p><p> (2)分区。计算机右键-管理-磁盘管理，选中一个磁盘(这里以D盘为例)右键磁盘压缩，压缩空间自己定，这个空间就是给linux系统，最好不要小于20G。<br><img src="http://pqk5lbhsc.bkt.clouddn.com/ubuntu1-1.png" alt="cmd-markdown-logo"></p><p> (3)刻录系统文件。刻录之前插入你的U盘，格式化。打开rufus软件设备选择你插入的U盘，软件会自动识别，镜像文件就选择你下载好ubuntu镜像文件，其它都是默认，不用改变。<br><img src="http://pqk5lbhsc.bkt.clouddn.com/ubuntu2-1.png" alt="cmd-markdown-logo"></p><p><img src="http://pqk5lbhsc.bkt.clouddn.com/ubuntu2-2.jpg" alt="cmd-markdown-logo"></p><p> 然后点击开始出现以下界面：选择以IOS镜像模式写入，点击OK，就开始刻录，完成之后点击关闭。<br><img src="http://pqk5lbhsc.bkt.clouddn.com/ubuntu2-3.png" alt="cmd-markdown-logo"></p><p> (4)拔出U盘，重启进入bios，设置U盘启动项，关机。</p><p> (5)插入U盘，启动电脑，按指定键进入选择启动项的界面，然后选择插入的U盘，回车之后就会看到ubuntu的引导界面。</p><p> (6)接下来选择第二个选项”Install Ubuntu”，进入安装。<br><img src="http://pqk5lbhsc.bkt.clouddn.com/ubuntu2-4.png" alt="cmd-markdown-logo"></p><p> (7)左边的栏里选择“中文简体”，之后点击安装Ubuntu<br><img src="http://pqk5lbhsc.bkt.clouddn.com/ubuntu2-5.png" alt="cmd-markdown-logo"></p><p> (8)先不联网，直接安装。<br><img src="http://pqk5lbhsc.bkt.clouddn.com/ubuntu2-6.png" alt="cmd-markdown-logo"></p><p> (9)继续安装<br><img src="http://pqk5lbhsc.bkt.clouddn.com/ubuntu2-7.png" alt="cmd-markdown-logo"></p><p> (10)到了最关键的一步了，这个时候系统会提示你是否与windows10共存。如果是新手，我们可以选择与win10共存，这样就避免了分区，非常简便。如果你想自己管理你的分区，那么就选择其他选项进行自定义分区。这里选择与windows10共存。<br> 注意:如果系统没提示你之前安装过windows，那么你的启动方式就错误了，你得回到BIOS页面下更改启动方式再次启动。<br><img src="http://pqk5lbhsc.bkt.clouddn.com/ubuntu2-8.png" alt="cmd-markdown-logo"></p><p> (11)选择上海。<br><img src="http://pqk5lbhsc.bkt.clouddn.com/ubuntu2-9.png" alt="cmd-markdown-logo"></p><p> (12)选择汉语。<br><img src="http://pqk5lbhsc.bkt.clouddn.com/ubuntu2-10.png" alt="cmd-markdown-logo"></p><p> (13)设置账号和密码。<br><img src="http://pqk5lbhsc.bkt.clouddn.com/ubuntu2-11.png" alt="cmd-markdown-logo"></p><p> (14)安装完成后重启系统会看到此界面，这就说明安装成功，ubuntu的引导带着win10的引导一起启动，这时可以选择你想进入的系统。这个界面排在第一位的是”ubuntu”,这样每次开机默认进入的是ubuntu系统，可以把win10系统排在第一位。<br><img src="http://pqk5lbhsc.bkt.clouddn.com/ubuntu2-12.png" alt="cmd-markdown-logo"></p><p> (15)进入ubuntu系统，按Ctrl+Altr+t打开命令行，输入命令：<br><code>sudo gedit /etc/default/grub</code>,要修改默认启动顺序，找到如下行<br><code>GRUB_DEFAULT=0</code><br> 该行就是启动时默认的选项,修改为自己Windows所在的值。例如我的启动项是(可以在启动界面看到)：<br>  0.Ubuntu启动<br>  1.Ubuntu配置<br>  2.Windows启动<br> 所以修改为<code>GRUB_DEFAULT=2</code>，重启后就可以看到，windows10排在了第一位，每次开机默认进入win10系统。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇文章是装win10-linux双系统最基本的方法，如果你的电脑是uefi引导的win10系统，这个方法可行。但是强调一点，如果是弘基电脑，那么请您绕行，对于弘基电脑来说，这种方法是不可行的。本人装过弘基电脑的双系统，但是装完之后会发现直接进入win10系统，没有linu
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>基于python和机器学习的微信跳一跳小程序破解</title>
    <link href="http://yoursite.com/2019/04/28/%E5%9F%BA%E4%BA%8Epython%E5%92%8C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%BE%AE%E4%BF%A1%E8%B7%B3%E4%B8%80%E8%B7%B3%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%A0%B4%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/04/28/基于python和机器学习的微信跳一跳小程序破解/</id>
    <published>2019-04-28T13:33:46.000Z</published>
    <updated>2019-04-28T13:59:56.626Z</updated>
    
    <content type="html"><![CDATA[<iframe height="400" width="715" src="http://pqk5lbhsc.bkt.clouddn.com/WechatWechat.mp4" frameborder="0" allowfullscreen><br></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;iframe height=&quot;400&quot; width=&quot;715&quot; src=&quot;http://pqk5lbhsc.bkt.clouddn.com/WechatWechat.mp4&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;br&gt;&lt;/iframe&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>最简单的方法重装win10系统</title>
    <link href="http://yoursite.com/2019/04/27/%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%B9%E6%B3%95%E9%87%8D%E8%A3%85win10%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2019/04/27/最简单的方法重装win10系统/</id>
    <published>2019-04-27T13:53:41.000Z</published>
    <updated>2019-04-30T07:33:03.114Z</updated>
    
    <content type="html"><![CDATA[<p><font size="3">到Microsoft官网下载安装工具,用这个工具安装win10系统非常方便。利用此工具不仅可以在原有系统重装win10，也可以用来做U盘启动项。</font><br><code>https://www.microsoft.com/zh-cn/software-download/windows10</code></p><p><img src="http://pqk5lbhsc.bkt.clouddn.com/windows2-42.jpg" alt="cmd-markdown-logo"></p><p><strong><font size="3">操作步骤</font></strong></p><p>1.如果电脑系统还可以进入，那就没必要做U盘启动项，直接在现有的系统里重装win10。</p><p> (1)右键，以管理员身份运行下载好的工具，利用工具下载Windows10原版系统。<br><img src="http://pqk5lbhsc.bkt.clouddn.com/windows2-38.jpg" alt="cmd-markdown-logo"></p><p> (2)选择第二个(下载IOS文件)，点下一步。<br><img src="http://pqk5lbhsc.bkt.clouddn.com/windows2-43.jpg" alt="cmd-markdown-logo"></p><p> (3)把“对这台电脑使用推荐的选项”对号去掉，就可以选择想要的系统。<br><img src="http://pqk5lbhsc.bkt.clouddn.com/windows2-45.jpg" alt="cmd-markdown-logo"></p><p> (4)此处选择IOS文件(U盘在后文中讲解)，点下一步。<br><img src="http://pqk5lbhsc.bkt.clouddn.com/windows2-46.jpg" alt="cmd-markdown-logo"></p><p> (5)开始下载win10系统，这系统是原版的系统，个人认为比那些在其他网站上下载的乱七八糟的系统要好。<br><img src="http://pqk5lbhsc.bkt.clouddn.com/windows2-47.jpg" alt="cmd-markdown-logo"></p><p> (6)将下载好的IOS文件解压到C盘之外的一个文件夹，这些文件就是安装系统所需要的文件啦。<br><img src="http://pqk5lbhsc.bkt.clouddn.com/windows2-39.jpg" alt="cmd-markdown-logo"></p><p> (7)右键“setup.exe”，以管理员身份运行，就开始安装系统了。<br><img src="http://pqk5lbhsc.bkt.clouddn.com/windows2-1.jpg" alt="cmd-markdown-logo"></p><p> (8)顺利进入安装向导，检查安装环境。<br><img src="http://pqk5lbhsc.bkt.clouddn.com/windows2-2.jpg" alt="cmd-markdown-logo"></p><p> (9)不更新，直接安装，速度更快，点击下一步。<br><img src="http://pqk5lbhsc.bkt.clouddn.com/windows2-3.jpg" alt="cmd-markdown-logo"></p><p> (10)这里选择win10专业版，可以根据自己的情况选择。<br><img src="http://pqk5lbhsc.bkt.clouddn.com/windows2-4.jpg" alt="cmd-markdown-logo"></p><p> (11)点击下一步。<br><img src="http://pqk5lbhsc.bkt.clouddn.com/windows2-5.jpg" alt="cmd-markdown-logo"></p><p> (12)看个人需要是否选择保留文件。<br><img src="http://pqk5lbhsc.bkt.clouddn.com/windows2-6.jpg" alt="cmd-markdown-logo"></p><p> (13)确认无误后安装，点击下一步。<br><img src="http://pqk5lbhsc.bkt.clouddn.com/windows2-7.jpg" alt="cmd-markdown-logo"></p><p> (14)开始安装，期间会多次重启，请耐心等待。<br><img src="http://pqk5lbhsc.bkt.clouddn.com/windows2-8.jpg" alt="cmd-markdown-logo"></p><p> (15)这个不解释。<br><img src="http://pqk5lbhsc.bkt.clouddn.com/windows2-9.jpg" alt="cmd-markdown-logo"></p><p> (16)不解释。<br><img src="http://pqk5lbhsc.bkt.clouddn.com/windows2-10.jpg" alt="cmd-markdown-logo"></p><p> (17)不解释。<br><img src="http://pqk5lbhsc.bkt.clouddn.com/windows2-11.jpg" alt="cmd-markdown-logo"></p><p> (18)选择针对个人。<br><img src="http://pqk5lbhsc.bkt.clouddn.com/windows2-12.jpg" alt="cmd-markdown-logo"></p><p> (19)创建账户和密码。<br><img src="http://pqk5lbhsc.bkt.clouddn.com/windows2-13.jpg" alt="cmd-markdown-logo"></p><p> (20)不解释。<br><img src="http://pqk5lbhsc.bkt.clouddn.com/windows2-14.jpg" alt="cmd-markdown-logo"></p><p> (21)不解释。<br><img src="http://pqk5lbhsc.bkt.clouddn.com/windows2-15.jpg" alt="cmd-markdown-logo"></p><p> (22)选择稍后再做。<br><img src="http://pqk5lbhsc.bkt.clouddn.com/windows2-16.jpg" alt="cmd-markdown-logo"></p><p> (23)根据需要选择。<br><img src="http://pqk5lbhsc.bkt.clouddn.com/windows2-17.jpg" alt="cmd-markdown-logo"></p><p> (24)一些设置。<br><img src="http://pqk5lbhsc.bkt.clouddn.com/windows2-18.jpg" alt="cmd-markdown-logo"></p><p> (25)配置电脑硬件，等一会就好了。<br><img src="http://pqk5lbhsc.bkt.clouddn.com/windows2-19.jpg" alt="cmd-markdown-logo"></p><p><img src="http://pqk5lbhsc.bkt.clouddn.com/windows2-20.jpg" alt="cmd-markdown-logo"></p><p> (26)敬请开始吧！<br><img src="http://pqk5lbhsc.bkt.clouddn.com/windows2-21.jpg" alt="cmd-markdown-logo"></p><p> (27)全新的win10系统！<br><img src="http://pqk5lbhsc.bkt.clouddn.com/windows2-22.jpg" alt="cmd-markdown-logo">，</p><p> (28)设置桌面图标：在桌面右键&gt;个性化&gt;主题&gt;桌面图标设置， 然后勾选你所需要显示的图标即可<br><img src="http://pqk5lbhsc.bkt.clouddn.com/windows2-23.jpg" alt="cmd-markdown-logo"></p><p> (29)查看系统激活情况。右键此电脑&gt;属性查看，新系统是没有激活的，下载一个系统激活软件，进行激活。(此处不做过多讲解)<br><img src="http://pqk5lbhsc.bkt.clouddn.com/windows2-24.jpg" alt="cmd-markdown-logo"></p><p>2.如果你的系统坏了，进不去了，这时你就要用U盘作为启动项安装系统。<br> (1)进入电脑Bios界面，设置引导模式，设置U盘启动。</p><p> (2)借一台同学的电脑，下载安装工具，文章开头已经写到。</p><p> (3)右键，以管理员身份运行下载好的工具，利用工具下载Windows10原版系统。<br><img src="http://pqk5lbhsc.bkt.clouddn.com/windows2-38.jpg" alt="cmd-markdown-logo"></p><p> (4)选择第二个(做系统U盘)，点下一步。<br><img src="http://pqk5lbhsc.bkt.clouddn.com/windows2-34.jpg" alt="cmd-markdown-logo"></p><p> (5)选择系统<br><img src="http://pqk5lbhsc.bkt.clouddn.com/windows2-35.jpg" alt="cmd-markdown-logo"></p><p> (6)选择U盘，之后选择自己插入电脑的U盘，此过程是先下载系统，之后再刻录文件，所以时间比较漫长。如果你有自己的系统文件，比如之前下载IOS文件，就可以用刻录软件将系统直接刻录到U盘里。<br><img src="http://pqk5lbhsc.bkt.clouddn.com/windows2-36.jpg" alt="cmd-markdown-logo"></p><p> (7)将刻录好的U盘插进要装系统的电脑，开机按指定键选择启动项。（不同电脑，按键不同。）<br><img src="http://pqk5lbhsc.bkt.clouddn.com/windows2-41.jpg" alt="cmd-markdown-logo"></p><p> (8)上下键选择U盘，回车进入即可安装系统，之后的步骤与上一种方法相同。<br><img src="http://pqk5lbhsc.bkt.clouddn.com/windows2-40.jpg" alt="cmd-markdown-logo"></p><p> (9)U盘可以选择4G的U盘，刻录完之后就可以用这个U盘随时给电脑装系统啦。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;font size=&quot;3&quot;&gt;到Microsoft官网下载安装工具,用这个工具安装win10系统非常方便。利用此工具不仅可以在原有系统重装win10，也可以用来做U盘启动项。&lt;/font&gt;&lt;br&gt;&lt;code&gt;https://www.microsoft.com/zh-cn/s
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MBR分区与GPT分区互转方法</title>
    <link href="http://yoursite.com/2019/04/26/MBR%E5%88%86%E5%8C%BA%E4%B8%8EGPT%E5%88%86%E5%8C%BA%E4%BA%92%E8%BD%AC%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/04/26/MBR分区与GPT分区互转方法/</id>
    <published>2019-04-26T14:08:13.000Z</published>
    <updated>2019-04-30T09:24:43.414Z</updated>
    
    <content type="html"><![CDATA[<font size="3">系统引导的两种方式：</font><br>UEFI启动模式：（GPT分区表格式+ UEFI启动模式+ x64的系统）<br>Legacy启动模式：（MBR主引导记录分区格式+ Legacy启动模式）<br><br>UEFI是新式的BIOS，Legacy是传统BIOS。在UEFI 模式下安装的系统，只能用UEFI模式引导；同理，如果在Legacy模式下安装的系统，也只能在Legacy模式下进系统。<br><br>UEFI可以引导win7和win10系统，但是磁盘分区必须是GPT模式，系统必须是64位，UEFI不支持32位系统。legacy也可以引导win7和win10系统，磁盘分区必须是MBR模式，系统可以是32位也可以是64位。<br><br>如果安装win10系统，推荐UEFI+GPT。因为win10系统默认就是uefi+gpt模式，这样才能发挥最佳性能。<br>如果安装win7系统，推荐legacy+MBR。<br>这两种搭配最常见的搭配，安装的系统不容易出现问题，其他的搭配个人觉得没有什么必要。当然，还是要根据自己的电脑情况来决定。比如一些老旧机型不支持uefi，只能是legacy引导。<br><br><font size="3">磁盘的两种分区格式：</font><br><strong>MBR</strong>，即主引导记录<br><strong>GPT</strong>，GUID的缩写<br>GPT分区与MBR分区方法相比，GPT具有更多的优点。MBR分区表的硬盘最多能划分4个主分区磁盘，并且MBR最大仅支持2TB的硬盘，GPT分区表类型不受分区个数、硬盘大小的限制。<br><br>通常情况下，如果win10系统想重装win7，需要把GPT转换为MBR，如果win7系统想重装win10，需要把MBR装换为GPT。<br><br><font color="#DC143C" size="3">注意：转换分区格式过程中均会清除磁盘中的所有分区和数据，所以在操作前请注意备份硬盘中的文件。</font><p><strong><font size="4">操作步骤：</font></strong></p><p>1.GPT转换成MBR<br> (1)通过U盘做一个简单的PE维护系统开机进入</p><p> (2)运行磁盘管理软件DiskGenius(一般PE都自带)<br><img src="http://pqk5lbhsc.bkt.clouddn.com/1-1.jpg" alt="cmd-markdown-logo"><br> (3)删除磁盘的所有分区</p><p><img src="http://pqk5lbhsc.bkt.clouddn.com/1-2.jpg" alt="cmd-markdown-logo"><br><img src="http://pqk5lbhsc.bkt.clouddn.com/1-3.jpg" alt="cmd-markdown-logo"><br><img src="http://pqk5lbhsc.bkt.clouddn.com/1-4.jpg" alt="cmd-markdown-logo"></p><p> (4)在磁盘处右键，选择“转换分区表类型为MBR格式<br><img src="http://pqk5lbhsc.bkt.clouddn.com/1-5.jpg" alt="cmd-markdown-logo"></p><p> (5)弹出如下提示窗口，选“确定”<br><img src="http://pqk5lbhsc.bkt.clouddn.com/1-6.jpg" alt="cmd-markdown-logo"></p><p> (6)至此，转换成MBR格式成功<br><img src="http://pqk5lbhsc.bkt.clouddn.com/1-7.jpg" alt="cmd-markdown-logo"></p><p> (7)最后，保存一下更改<br><img src="http://pqk5lbhsc.bkt.clouddn.com/1-8.jpg" alt="cmd-markdown-logo"></p><p>（8）给新转换好格式的磁盘重新分区一下即可正常使用；分区方法请看下图，按箭头顺序操作即可<br><img src="http://pqk5lbhsc.bkt.clouddn.com/1-9.jpg" alt="cmd-markdown-logo"></p><p>2.MBR转换成GPT<br> (1)进入PE系统</p><p> (2)运行磁盘管理软件DiskGenius(一般PE都自带)<br><img src="http://pqk5lbhsc.bkt.clouddn.com/1-1.jpg" alt="cmd-markdown-logo"><br><img src="http://pqk5lbhsc.bkt.clouddn.com/1-10.jpg" alt="cmd-markdown-logo"></p><p> (3)删除原磁盘中的所有分区<br><img src="http://pqk5lbhsc.bkt.clouddn.com/1-11.jpg" alt="cmd-markdown-logo"><br><img src="http://pqk5lbhsc.bkt.clouddn.com/1-12.jpg" alt="cmd-markdown-logo"></p><p> (4)在磁盘处右键，选择“转换分区表类型为GUID格式”<br><img src="http://pqk5lbhsc.bkt.clouddn.com/1-13.jpg" alt="cmd-markdown-logo"></p><p> (5)弹出提示窗口，选“确定”<br><img src="http://pqk5lbhsc.bkt.clouddn.com/1-14.jpg" alt="cmd-markdown-logo"></p><p> (6)最后，别忘了保存一下更改<br><img src="http://pqk5lbhsc.bkt.clouddn.com/1-16.jpg" alt="cmd-markdown-logo"></p><p> (7)给新转换好格式的磁盘重新分区一下即可正常使用；分区方法请看下图，按箭头顺序操作即可<br><img src="http://pqk5lbhsc.bkt.clouddn.com/1-17.jpg" alt="cmd-markdown-logo"></p><p> (8)最终效果<br><img src="http://pqk5lbhsc.bkt.clouddn.com/1-18.jpg" alt="cmd-markdown-logo"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font size=&quot;3&quot;&gt;系统引导的两种方式：&lt;/font&gt;&lt;br&gt;UEFI启动模式：（GPT分区表格式+ UEFI启动模式+ x64的系统）&lt;br&gt;Legacy启动模式：（MBR主引导记录分区格式+ Legacy启动模式）&lt;br&gt;&lt;br&gt;UEFI是新式的BIOS，Legac
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>表白神器:Arduino-LCD</title>
    <link href="http://yoursite.com/2019/04/21/Arduinono-LCD/"/>
    <id>http://yoursite.com/2019/04/21/Arduinono-LCD/</id>
    <published>2019-04-21T15:45:29.000Z</published>
    <updated>2019-05-16T11:06:28.247Z</updated>
    
    <content type="html"><![CDATA[<p>Arduino是一款便捷灵活、方便上手的开源电子原型平台。Arduino能通过各种各样的传感器来感知环境，通过控制灯光、马达和其他的装置来反馈、影响环境。板子上的微控制器可以通过Arduino的编程语言来编写程序，编译成二进制文件，烧录进微控制器。</p><p>#讲解#</p><p>##材料准备#</p><ul><li>Arduino UNO板子</li><li>LCD1602显示屏</li><li>杜邦线若干</li></ul><blockquote><p>这是一段引用代码<br><img src="https://www.zybuluo.com/static/img/logo.png" alt="cmd-markdown-logo"></p></blockquote><p><code>我是单行文本</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一行</span><br><span class="line">第二行</span><br><span class="line">第三行</span><br></pre></td></tr></table></figure><p>hexo new post “hello”</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Arduino是一款便捷灵活、方便上手的开源电子原型平台。Arduino能通过各种各样的传感器来感知环境，通过控制灯光、马达和其他的装置来反馈、影响环境。板子上的微控制器可以通过Arduino的编程语言来编写程序，编译成二进制文件，烧录进微控制器。&lt;/p&gt;
&lt;p&gt;#讲解#&lt;
      
    
    </summary>
    
    
  </entry>
  
</feed>
