<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>记录学习点滴</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-28T05:10:02.973Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>YuemingBi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Turtlebot2+RplidarA2 Learning Notes</title>
    <link href="http://yoursite.com/2019/07/28/Turtlebot2-RplidarA2-Learning-Notes/"/>
    <id>http://yoursite.com/2019/07/28/Turtlebot2-RplidarA2-Learning-Notes/</id>
    <published>2019-07-28T04:44:53.000Z</published>
    <updated>2019-07-28T05:10:02.973Z</updated>
    
    <content type="html"><![CDATA[<p><font size="3">Turtlebot + RplidarA2使用Gmapping建图与导航</font><br>在已有rocon、kobuki和turtlebot的条件下<br>1.安装turbot<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/catkin_ws/src</span><br><span class="line">$ git clone https://github.com/ncnynl/turbot</span><br><span class="line">$ cd ..</span><br><span class="line">$ catkin_make</span><br><span class="line">$ source devel/setup.bash</span><br></pre></td></tr></table></figure></p><p>2.安装turtlebot_apps<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/catkin_ws/src</span><br><span class="line">$ git clone https://github.com/ncnynl/turtlebot_apps</span><br><span class="line">$ cd ..</span><br><span class="line">$ catkin_make</span><br><span class="line">$ source devel/setup.bash</span><br></pre></td></tr></table></figure></p><p>3.安装雷达驱动程序<br>3.1 安装雷达驱动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/catkin_ws/src</span><br><span class="line">$ git clone https://github.com/robopeak/rplidar_ros</span><br><span class="line">$ cd ..</span><br><span class="line">$ catkin_make</span><br><span class="line">$ source devel/setup.bash</span><br></pre></td></tr></table></figure></p><p>3.2 设置USB权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim /etc/udev/rules.d/70-ttyusb.rules</span><br></pre></td></tr></table></figure></p><p>输入以下内容并保存退出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ KERNEL==&quot;ttyUSB[0-9]*&quot;, MODE=&quot;0666&quot;</span><br></pre></td></tr></table></figure></p><p>运行如下程序，查看权限，有两个rw就可以了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l /dev |grep ttyUSB*</span><br></pre></td></tr></table></figure></p><p>3.3 添加环境变量和工作空间，增加雷达别名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;export TURTLEBOT_LASER_SENSOR=rplidar&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">$ echo &quot;source ~/catkin_ws/devel/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">$ roscd rplidar_ros </span><br><span class="line">$ ./scripts/create_udev_rules.sh</span><br></pre></td></tr></table></figure></p><p>3.4 雷达启动测试（测试之前把雷达拔出，重新插进去）<br>驱动里提供了三个 launch 文件，检验雷达的话用 rplidar.launch 即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ roslaunch rplidar_ros rplidar.launch</span><br></pre></td></tr></table></figure></p><p>可以观察到雷达开始旋转扫描，之后可以先关闭<br>3.5 使用turbot程序驱动雷达<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ roslaunch turbot_tools rplidar.launch</span><br><span class="line">$ roslaunch turbot_tools test_rplidar.launch</span><br></pre></td></tr></table></figure></p><p>可以看到在打开的RVIZ界面上有雷达扫描的点云图形</p><p>4.使用Gmapping建图<br>启动底盘<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ roslaunch turbot_bringup minimal.launch</span><br><span class="line">或(roslaunch turtlebot_bringup minimal.launch)</span><br></pre></td></tr></table></figure></p><p>启动gmapping<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ roslaunch turbot_slam laser_gmapping_demo.launch</span><br></pre></td></tr></table></figure></p><p>启动rviz<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ roslaunch turbot_rviz nav.launch</span><br></pre></td></tr></table></figure></p><p>启动键盘<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ roslaunch turbot_teleop keyboard.launch</span><br></pre></td></tr></table></figure></p><p>保存地图，先建立一个map文件夹<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rosrun map_server map_saver -f ~/map/rplidar_a2_gmapping</span><br><span class="line">$ ls ~/map</span><br></pre></td></tr></table></figure></p><p>可以查看到map文件夹下有两个文件，一个是.pgm文件，另一个是.yaml文件。可以打开.pgm文件查看建成的地图。</p><p>5.AMCL导航<br>启动底盘<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ roslaunch turbot_bringup minimal.launch</span><br></pre></td></tr></table></figure></p><p>启动amcl，并指定地图<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ roslaunch turbot_slam laser_amcl_demo.launch map_file:=~/map/rplidar_a2_gmapping.yaml</span><br></pre></td></tr></table></figure></p><p>启动rviz<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ roslaunch turbot_rviz nav.launch</span><br></pre></td></tr></table></figure></p><p>初始化位置，选择2D Pose Estimate，标注机器人在地图上的位置和方向，按住鼠标左键拉向某个方向。<br>设置目标位置，选择“2D Nav Goal”， 标注机器人将要到达地图上的位置和方向，按住鼠标左键拉向某个方向。<br>机器人规划出一条路径，然后自动走向目标点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;font size=&quot;3&quot;&gt;Turtlebot + RplidarA2使用Gmapping建图与导航&lt;/font&gt;&lt;br&gt;在已有rocon、kobuki和turtlebot的条件下&lt;br&gt;1.安装turbot&lt;br&gt;&lt;figure class=&quot;highlight pla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SLAM-Exercise-Ch4</title>
    <link href="http://yoursite.com/2019/07/17/SLAM-Exercise-Ch4/"/>
    <id>http://yoursite.com/2019/07/17/SLAM-Exercise-Ch4/</id>
    <published>2019-07-17T01:08:42.000Z</published>
    <updated>2019-07-17T01:32:08.584Z</updated>
    
    <content type="html"><![CDATA[<p><font size="3">《视觉SLAM十四讲从理论到实践》第四讲课后习题</font><br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/SLAM-Exercise-Ch4/1.png" alt="waitting"><br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/SLAM-Exercise-Ch4/1-1.png" alt="waitting"><br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/SLAM-Exercise-Ch4/1-2.png" alt="waitting"><br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/SLAM-Exercise-Ch4/2-1.png" alt="waitting"><br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/SLAM-Exercise-Ch4/2.png" alt="waitting"><br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/SLAM-Exercise-Ch4/3-1.png" alt="waitting"><br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/SLAM-Exercise-Ch4/3.png" alt="waitting"><br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/SLAM-Exercise-Ch4/4.png" alt="waitting"><br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/SLAM-Exercise-Ch4/4-1-1.png" alt="waitting"><br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/SLAM-Exercise-Ch4/4-2-1.png" alt="waitting"><br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/SLAM-Exercise-Ch4/4-1.png" alt="waitting"><br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/SLAM-Exercise-Ch4/4-2.png" alt="waitting"><br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/SLAM-Exercise-Ch4/5.png" alt="waitting"><br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/SLAM-Exercise-Ch4/6.png" alt="waitting"><br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/SLAM-Exercise-Ch4/7.png" alt="waitting"><br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/SLAM-Exercise-Ch4/8.png" alt="waitting"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;font size=&quot;3&quot;&gt;《视觉SLAM十四讲从理论到实践》第四讲课后习题&lt;/font&gt;&lt;br&gt;&lt;img src=&quot;https://github.com/YuemingBi/comment-repo/raw/master/image/SLAM-Exercise-Ch4/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Eigen-Learning-Notes(4)</title>
    <link href="http://yoursite.com/2019/07/17/Eigen-Learning-Notes-4/"/>
    <id>http://yoursite.com/2019/07/17/Eigen-Learning-Notes-4/</id>
    <published>2019-07-17T01:01:54.000Z</published>
    <updated>2019-07-17T01:05:25.477Z</updated>
    
    <content type="html"><![CDATA[<p><font size="3">Eigen-Learning-Notes(4)</font><br>利用Eigen库和Sophus库实现李群SO(3)、SE(3)和李代数so(3)、se(3)的简单构造<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#include&lt;Eigen/Core&gt;</span><br><span class="line">#include&lt;Eigen/Geometry&gt;</span><br><span class="line"></span><br><span class="line">#include&lt;sophus/so3.h&gt;</span><br><span class="line">#include&lt;sophus/se3.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    Eigen::Matrix3d R = Eigen::AngleAxisd (M_PI/2, Eigen::Vector3d (0,0,1)).toRotationMatrix();  // 沿Z轴转90度的旋转矩阵</span><br><span class="line"></span><br><span class="line">    Sophus::SO3 SO3_R(R);             //Sophus::SO(3)可以直接从旋转矩阵构造</span><br><span class="line">    Sophus::SO3 SO3_v(0, 0, M_PI/2);  //亦可从旋转向量构造</span><br><span class="line">    //Sophus::SO3 SO3_v(1,1,1);  //此处的输出并不是1,1,1，所以与旋转向量无关</span><br><span class="line">    Eigen::Quaterniond q(R);          // 或者四元数</span><br><span class="line">    Sophus::SO3 SO3_q(q);</span><br><span class="line">    cout &lt;&lt; &quot;SO3 from matrix: \n&quot; &lt;&lt; SO3_R &lt;&lt; endl;//从输出的形式可以看出，虽然SO3是李群，是旋转矩阵，但是输出形式还是向量（被转化成李代数输出）。输出SO(3)时，以so(3)形式输出</span><br><span class="line">    cout &lt;&lt; &quot;SO3 from vector: &quot; &lt;&lt; SO3_v &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;SO3 from quaternion &quot; &lt;&lt; SO3_q &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3d so3 = SO3_R.log();  // 使用对数映射获得它的李代数</span><br><span class="line">    cout &lt;&lt; &quot;so3 = &quot; &lt;&lt; so3.transpose() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;so3 hat = \n&quot; &lt;&lt; Sophus::SO3::hat(so3) &lt;&lt; endl;  // hat 为向量到反对称矩阵</span><br><span class="line">    cout &lt;&lt; &quot;so3 hat vee = &quot; &lt;&lt; Sophus::SO3::vee(Sophus::SO3::hat(so3)).transpose() &lt;&lt; endl;  //vee为反对称到向量</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3d update_so3 (1e-4, 0, 0);  // 增量扰动模型的更新</span><br><span class="line">    Sophus::SO3 SO3_updated = Sophus::SO3::exp(update_so3) * SO3_R;</span><br><span class="line">    cout &lt;&lt; &quot;SO3_updated = &quot; &lt;&lt; SO3_updated &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    //对SE(3)操作大同小异</span><br><span class="line">    Eigen::Vector3d t (1,0,0);  // 沿X轴平移1</span><br><span class="line">    Sophus::SE3 SE3_Rt (R, t);  // 从R,t构造SE(3)</span><br><span class="line">    Sophus::SE3 SE3_qt (q, t);  //// 从q,t构造SE(3)</span><br><span class="line">    cout &lt;&lt; &quot;SE3 from Rt = \n&quot; &lt;&lt; SE3_Rt &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;SE3 from qt = \n&quot; &lt;&lt; SE3_qt &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    typedef Eigen::Matrix&lt;double, 6, 1&gt; Vector6d;  // 李代数se(3) 是一个六维向量，方便起见先typedef一下</span><br><span class="line">    Vector6d se3 = SE3_Rt.log();</span><br><span class="line">    cout &lt;&lt; &quot;se3 = &quot; &lt;&lt; se3.transpose() &lt;&lt; endl;   // 观察输出，会发现在Sophus中，se(3)的平移在前，旋转在后.</span><br><span class="line">    cout &lt;&lt; &quot;se3 hat = \n&quot; &lt;&lt; Sophus::SE3::hat(se3) &lt;&lt; endl;  // 同样的，有hat和vee两个算符</span><br><span class="line">    cout &lt;&lt; &quot;se3 vee = &quot; &lt;&lt; Sophus::SE3::vee(Sophus::SE3::hat(se3)).transpose() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Vector6d update_se3; //更新量</span><br><span class="line">    update_se3.setZero();</span><br><span class="line">    update_se3(0,0) = 1e-4d;</span><br><span class="line">    cout &lt;&lt; &quot;update_se3 = &quot; &lt;&lt; update_se3.transpose() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;font size=&quot;3&quot;&gt;Eigen-Learning-Notes(4)&lt;/font&gt;&lt;br&gt;利用Eigen库和Sophus库实现李群SO(3)、SE(3)和李代数so(3)、se(3)的简单构造&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Eigen-Learning-Notes(3)</title>
    <link href="http://yoursite.com/2019/07/11/Eigen-Learning-Notes-3/"/>
    <id>http://yoursite.com/2019/07/11/Eigen-Learning-Notes-3/</id>
    <published>2019-07-11T06:22:59.000Z</published>
    <updated>2019-07-11T06:37:37.979Z</updated>
    
    <content type="html"><![CDATA[<p><font size="3">Eigen-Learning-Notes(3)</font><br>视觉SLAM十四讲ch3里面的一道题目：设有小萝卜一号和小萝卜二号位于世界坐标系中。小萝卜一号的位姿为:q 1 =[0.35, 0.2, 0.3, 0.1], t 2 = [0.3, 0.1, 0.1] T (q 的第一项为实部。请你把 q 归一化后再进行计算)。这里的 q 和 t 表达的是 T cw ,也就是世界到相机的变换关系。小萝卜二号的位姿为 q 2 = [−0.5, 0.4,−0.1, 0.2], t = [−0.1, 0.5, 0.3] T 。现在,小萝卜一号看到某个点在自身的坐标系下,坐标为 p = [0.5, 0, 0.2] T ,求该向量在小萝卜二号坐标系下的坐标。请编程实现此事。<br>分析：<br>     Tcw1:世界坐标到小萝卜1的坐标的转换关系（把小萝卜1看成相机1）<br>     Tcw2:世界坐标到小萝卜2的坐标的转化关系（把小萝卜2看成相机2）<br>     点p1:小萝卜1自身坐标系（相机1坐标系）下的一个点<br>     点p2:小萝卜2在自身坐标系（相机2坐标系）下看到点p的坐标<br>     点d：点p在世界坐标系下的坐标<br>     在转换过程当中，d点的坐标不变，所以可以得出 p=Tcw1<em>d, p1=Tcw2</em>d，因此求出d即可求p1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#include&lt;Eigen/Core&gt;</span><br><span class="line">#include&lt;Eigen/Dense&gt;</span><br><span class="line">#include&lt;Eigen/Geometry&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    Eigen::Quaternion&lt;double&gt; q1 (0.55,0.3,0.2,0.2);   //小萝卜1的四元数</span><br><span class="line">    Eigen::Quaternion&lt;double&gt; q2 (-0.1,0.3,-0.7,0.2);  //小萝卜2的四元数</span><br><span class="line">    q1.normalize();  //四元数归一化,四元数使用之前要归一化</span><br><span class="line">    q2.normalize();</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3d t1 (0.7,1.1,0.2);  //小萝卜1的平移向量</span><br><span class="line">    Eigen::Vector3d t2 (-0.1,0.4,0.8); //小萝卜2的平移向量</span><br><span class="line"></span><br><span class="line">    Eigen::Matrix3d R1 = q1.toRotationMatrix(); //将四元数转换为旋转矩阵</span><br><span class="line">    Eigen::Matrix3d R2 = q2.toRotationMatrix();</span><br><span class="line"></span><br><span class="line">    Eigen::Isometry3d Tcw1 (q1);  //创建小萝卜1号的欧氏变换矩阵，并用旋转矩阵初始化  此处也可以写成Eigen::Isometry3d Tcw1 (R1) (用旋转矩阵和四元数都可以)</span><br><span class="line">    Eigen::Isometry3d Tcw2 (q2);  //创建小萝卜2号的欧氏变换矩阵，并用旋转矩阵初始化  此处也可以写成Eigen::Isometry3d Tcw2 (R2)</span><br><span class="line">    /*或者这么写</span><br><span class="line">    Eigen::Isometry3d Tcw1 = Eigen::Isometry3d::Identity();</span><br><span class="line">    Eigen::Isometry3d Tcw2 = Eigen::Isometry3d::Identity();</span><br><span class="line">    Tcw1.rotate(R1);</span><br><span class="line">    Tcw2.rotate(R2);</span><br><span class="line">    */</span><br><span class="line">    Tcw1.pretranslate(t1);  //用平移向量初始化小萝卜1号的欧氏变换矩阵</span><br><span class="line">    Tcw2.pretranslate(t2);  //用平移向量初始化小萝卜2号的欧氏变换矩阵</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3d p1 (0.5,-0.1,0.2);           //初始化p1</span><br><span class="line">    Eigen::Vector3d d = Tcw1.inverse()*p1;       //求出d</span><br><span class="line">    Eigen::Vector3d p2 = Tcw2*d;                 //求出p2</span><br><span class="line">    cout &lt;&lt; &quot;p2 = &quot; &lt;&lt; p2.transpose() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;font size=&quot;3&quot;&gt;Eigen-Learning-Notes(3)&lt;/font&gt;&lt;br&gt;视觉SLAM十四讲ch3里面的一道题目：设有小萝卜一号和小萝卜二号位于世界坐标系中。小萝卜一号的位姿为:q 1 =[0.35, 0.2, 0.3, 0.1], t 2 = [0
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Eigen-Learning-Notes(2)</title>
    <link href="http://yoursite.com/2019/07/11/Eigen-Learning-Notes-2/"/>
    <id>http://yoursite.com/2019/07/11/Eigen-Learning-Notes-2/</id>
    <published>2019-07-11T06:22:52.000Z</published>
    <updated>2019-07-11T06:32:04.979Z</updated>
    
    <content type="html"><![CDATA[<p><font size="3">Eigen-Learning-Notes(2)</font><br>旋转矩阵、旋转向量、欧拉角、变换矩阵和四元数的声明、初始化和坐标变换，以下代码为Ubuntu下的C++实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#include&lt;Eigen/Core&gt;</span><br><span class="line">#include&lt;Eigen/Dense&gt;</span><br><span class="line">#include&lt;Eigen/Geometry&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    //旋转矩阵和旋转向量</span><br><span class="line">    Eigen::Matrix3d rotation_matrix = Eigen::Matrix3d::Identity();</span><br><span class="line">    Eigen::AngleAxisd rotation_vector (M_PI/4, Eigen::Vector3d(0,0,1));  //定义旋转向量</span><br><span class="line">    cout &lt;&lt; &quot;rotation_matrix = \n&quot; &lt;&lt; rotation_vector.matrix() &lt;&lt; endl; //旋转向量转换成矩阵</span><br><span class="line">    rotation_matrix = rotation_vector.toRotationMatrix();                     //也可以这样转换</span><br><span class="line">    cout &lt;&lt; &quot;rotation_matrix = \n&quot; &lt;&lt; rotation_matrix &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    //用旋转矩阵和旋转向量进行坐标变换</span><br><span class="line">    Eigen::Vector3d v (1,0,0);</span><br><span class="line">    Eigen::Vector3d v_rotated = rotation_matrix * v;</span><br><span class="line">    cout &lt;&lt; &quot;v_rotated = &quot; &lt;&lt; v_rotated.transpose() &lt;&lt; endl;</span><br><span class="line">    v_rotated = rotation_vector * v;</span><br><span class="line">    cout &lt;&lt; &quot;v_rotated = &quot; &lt;&lt; v_rotated.transpose() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    //欧拉角</span><br><span class="line">    Eigen::Vector3d euler_angles = rotation_matrix.eulerAngles(2,1,0);  // 2,1,0表示ZYX顺序，即yaw pitch roll顺序</span><br><span class="line">    cout &lt;&lt; &quot;yaw pitch roll = &quot; &lt;&lt; euler_angles.transpose() &lt;&lt; endl;    //输出为PI/4</span><br><span class="line"></span><br><span class="line">    //变换矩阵</span><br><span class="line">    Eigen::Isometry3d T = Eigen::Isometry3d::Identity();</span><br><span class="line">    T.rotate (rotation_vector);  //或者：T.Rotate (rotation_matrix)</span><br><span class="line">    T.pretranslate (Eigen::Vector3d (1,3,4));</span><br><span class="line">    cout &lt;&lt; &quot;Transform matrix = \n&quot; &lt;&lt; T.matrix() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    //用变换矩阵进行坐标变换</span><br><span class="line">    Eigen::Vector3d v_transformed = T*v;</span><br><span class="line">    cout &lt;&lt; &quot;v_transformed = &quot; &lt;&lt; v_transformed.transpose() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    //四元数</span><br><span class="line">    Eigen::Quaterniond q = Eigen::Quaterniond (rotation_vector);</span><br><span class="line">    //或者：Eigen::Quaterniond q = Eigen::Quaterniond (rotation_matrix);</span><br><span class="line">    cout &lt;&lt; &quot;q = \n&quot; &lt;&lt; q.coeffs() &lt;&lt; endl;</span><br><span class="line">    q = Eigen::Quaterniond (rotation_matrix);</span><br><span class="line">    cout &lt;&lt; &quot;q = \n&quot; &lt;&lt; q.coeffs() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    //利用四元数进行坐标变换</span><br><span class="line">    v_rotated = q*v;</span><br><span class="line">    cout &lt;&lt; &quot;v_rotated = &quot; &lt;&lt; v_rotated.transpose() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;font size=&quot;3&quot;&gt;Eigen-Learning-Notes(2)&lt;/font&gt;&lt;br&gt;旋转矩阵、旋转向量、欧拉角、变换矩阵和四元数的声明、初始化和坐标变换，以下代码为Ubuntu下的C++实现。&lt;br&gt;&lt;figure class=&quot;highlight plain
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Eigen-Learning-Notes(1)</title>
    <link href="http://yoursite.com/2019/07/11/Eigen-Learning-Notes-1/"/>
    <id>http://yoursite.com/2019/07/11/Eigen-Learning-Notes-1/</id>
    <published>2019-07-11T06:22:26.000Z</published>
    <updated>2019-07-11T06:31:35.269Z</updated>
    
    <content type="html"><![CDATA[<p><font size="3">Eigen-Learning-Notes(1)</font><br>矩阵和向量的初始化以及一些常用的运算，以下代码为Ubuntu下的C++实现，需要安装Eigen库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#include&lt;Eigen/Core&gt;  // Eigen 部分</span><br><span class="line">#include&lt;Eigen/Dense&gt;  // 稠密矩阵的代数运算（逆，特征值等）</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    // 矩阵和向量 Eigen::Matrix它的前三个参数为：数据类型，行，列</span><br><span class="line">    Eigen::Matrix&lt;float, 2, 3&gt; matrix_23;  // 声明一个2*3的float矩阵</span><br><span class="line">    Eigen::Vector3d v_3d;  //Vector3d实质上是Eigen::Matrix&lt;double, 3, 1&gt;，即三维向量</span><br><span class="line">    Eigen::Matrix&lt;float,3,1&gt; vd_3d; //这也是三维向量</span><br><span class="line">    Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic &gt; matrix_dynamic;  // 如果不确定矩阵大小，可以使用动态大小的矩阵</span><br><span class="line">    Eigen::MatrixXd matrix_x;  // 更简单的</span><br><span class="line"></span><br><span class="line">    //矩阵和向量的初始化和输出</span><br><span class="line">    matrix_23 &lt;&lt; 1, 2, 3, 4, 5, 6;  // 输入数据（初始化）</span><br><span class="line">    Eigen::Vector4d v_4d (1, 2, 3, 4);  //向量可以在定义的时候直接初始化</span><br><span class="line">    cout &lt;&lt; &quot;matrix_23 = \n&quot; &lt;&lt; matrix_23 &lt;&lt; endl;  // 输出</span><br><span class="line">    cout &lt;&lt; &quot;v_4d = &quot; &lt;&lt; v_4d.transpose() &lt;&lt; endl;</span><br><span class="line">    Eigen::Matrix&lt;float, 3, 2&gt; matrix_32 = Eigen::Matrix&lt;float, 3, 2&gt;::Random();  //随机数矩阵</span><br><span class="line">    Eigen::Matrix3d matrix_33 = Eigen::Matrix3d::Identity();                      //单位矩阵</span><br><span class="line">    Eigen::Matrix&lt;float, 3, 4&gt; matrix_34 = Eigen::Matrix&lt;float, 3, 4&gt;::Zero();    //初始化为零</span><br><span class="line">    cout &lt;&lt; &quot;matrix_32 = \n&quot; &lt;&lt; matrix_32 &lt;&lt; endl;  // 输出</span><br><span class="line">    cout &lt;&lt; &quot;matrix_33 = \n&quot; &lt;&lt; matrix_33 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;matrix_34 = \n&quot; &lt;&lt; matrix_34 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    //用for循环访问矩阵中的元素</span><br><span class="line">    for(int i = 0; i &lt; 2; i ++)</span><br><span class="line">      for(int j = 0; j &lt; 3; j ++)</span><br><span class="line">        cout &lt;&lt; matrix_23(i, j) &lt;&lt; &quot; &quot;;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    //矩阵的运算</span><br><span class="line">    v_3d &lt;&lt; 3, 2, 1; vd_3d &lt;&lt; 4,5,6;</span><br><span class="line">    Eigen::Matrix&lt;double, 2, 1&gt; result1 = matrix_23.cast&lt;double&gt;() * v_3d; //类型转换</span><br><span class="line">    cout &lt;&lt; &quot;result1 = \n&quot; &lt;&lt; result1 &lt;&lt; endl;</span><br><span class="line">    Eigen::Matrix&lt;float, 2, 1&gt; result2 = matrix_23 * vd_3d;</span><br><span class="line">    cout &lt;&lt; &quot;result2 = \n&quot; &lt;&lt; result2 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;matrix_33.transpose() = \n&quot; &lt;&lt; matrix_33.transpose() &lt;&lt; endl;      // 转置</span><br><span class="line">    cout &lt;&lt; &quot;matrix_33.sum() = &quot; &lt;&lt; matrix_33.sum() &lt;&lt; endl;            // 各元素和</span><br><span class="line">    cout &lt;&lt; &quot;matrix_33.trace() = &quot; &lt;&lt; matrix_33.trace() &lt;&lt; endl;          // 迹</span><br><span class="line">    cout &lt;&lt; &quot;10*matrix_33 = \n&quot; &lt;&lt; 10*matrix_33 &lt;&lt; endl;               // 数乘</span><br><span class="line">    cout &lt;&lt; &quot;matrix_33.inverse() = \n&quot; &lt;&lt; matrix_33.inverse() &lt;&lt; endl;        // 逆</span><br><span class="line">    cout &lt;&lt; &quot;matrix_33.determinant() = &quot; &lt;&lt; matrix_33.determinant() &lt;&lt; endl;    // 行列式</span><br><span class="line"></span><br><span class="line">    //求特征值和特征向量</span><br><span class="line">    Eigen::SelfAdjointEigenSolver&lt;Eigen::Matrix3d&gt; eigen_solver ( matrix_33.transpose()*matrix_33 );</span><br><span class="line">    cout &lt;&lt; &quot;Eigen values = \n&quot; &lt;&lt; eigen_solver.eigenvalues() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;Eigen vectors = \n&quot; &lt;&lt; eigen_solver.eigenvectors() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    //解方程 matrix_NN * x = v_Nd</span><br><span class="line">    Eigen::Matrix&lt; double, 50, 50 &gt; matrix_NN = Eigen::MatrixXd::Random( 50, 50 );</span><br><span class="line">    Eigen::Matrix&lt; double, 50, 1&gt; v_Nd = Eigen::MatrixXd::Random( 50,1 );</span><br><span class="line"></span><br><span class="line">    clock_t time_stt = clock(); // 计时</span><br><span class="line">    Eigen::Matrix&lt;double,50,1&gt; x = matrix_NN.inverse()*v_Nd; //直接求逆，计算量大</span><br><span class="line">    cout &lt;&lt;&quot;time use in normal inverse is &quot; &lt;&lt; 1000* (clock() - time_stt)/(double)CLOCKS_PER_SEC &lt;&lt; &quot;ms&quot;&lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    time_stt = clock();</span><br><span class="line">    x = matrix_NN.colPivHouseholderQr().solve(v_Nd);  //QR分解法，速度更快</span><br><span class="line">    cout &lt;&lt;&quot;time use in Qr decomposition is &quot; &lt;&lt;1000*  (clock() - time_stt)/(double)CLOCKS_PER_SEC &lt;&lt;&quot;ms&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;font size=&quot;3&quot;&gt;Eigen-Learning-Notes(1)&lt;/font&gt;&lt;br&gt;矩阵和向量的初始化以及一些常用的运算，以下代码为Ubuntu下的C++实现，需要安装Eigen库。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;ta
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Quaternions-Learning-Notes</title>
    <link href="http://yoursite.com/2019/07/10/Quaternions-Learning-Notes/"/>
    <id>http://yoursite.com/2019/07/10/Quaternions-Learning-Notes/</id>
    <published>2019-07-10T06:53:18.000Z</published>
    <updated>2019-07-11T06:43:43.752Z</updated>
    
    <content type="html"><![CDATA[<font size="3">四元数学习笔记</font><p>基本概念：<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/Quaternions-Learning-Notes/1.png" alt="waitting"></p><p>模长：<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/Quaternions-Learning-Notes/2.png" alt="waitting"></p><p>逆：<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/Quaternions-Learning-Notes/3.png" alt="waitting"></p><p>复数表示旋转：<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/Quaternions-Learning-Notes/4.jpg" alt="waitting"></p><p>四元数三角函数表示式：<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/Quaternions-Learning-Notes/5.jpg" alt="waitting"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font size=&quot;3&quot;&gt;四元数学习笔记&lt;/font&gt;

&lt;p&gt;基本概念：&lt;br&gt;&lt;img src=&quot;https://github.com/YuemingBi/comment-repo/raw/master/image/Quaternions-Learning-Notes/1
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Machine Learning : ROC and AUC</title>
    <link href="http://yoursite.com/2019/07/07/%C2%96Machine-Learning-ROC-and-AUC/"/>
    <id>http://yoursite.com/2019/07/07/Machine-Learning-ROC-and-AUC/</id>
    <published>2019-07-07T02:53:55.000Z</published>
    <updated>2019-07-07T06:23:16.238Z</updated>
    
    <content type="html"><![CDATA[<font size="3">机器学习之ROC和AUC</font><p><font size="4">1.ROC：<font size="4"><br>在机器学习理论中，可用ROC曲线来分析二元分类模型。在二分类问题中，数据的标签通常用（0/1）来表示，在模型训练完成后进行测试时，会对测试集的每个样本计算一个介于 0~1 之间的概率，表征模型认为该样本为阳性的概率。我们可以选定一个阈值，将模型计算出的概率进行二值化，比如选定阈值等于0.5，那么当模型输出的值大于等于 0.5 时，我们就认为模型将该样本预测为阳性，也就是标签为 1，反之亦然。选定的阈值不同，模型预测的结果也会相应地改变。二元分类模型的单个样本预测有四种结果：<br>真阳性（TP）：判断为阳性，实际也是阳性。<br>伪阳性（FP）：判断为阳性，实际却是阴性。<br>真阴性（TN）：判断为阴性，实际也是阴性。<br>伪阴性（FN）：判断为阴性，实际却是阳性。<br>这四种结果可以画成 2×2 的混淆矩阵：<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/Machine Learing ROC and AUC/1.png" alt="waitting"><br>有了混淆矩阵，就可以定义ROC曲线了。ROC曲线将假阳性率（FPR）定义为X轴，真阳性率（TPR）定义为 Y 轴。其中：<br>TPR：在所有实际为阳性的样本中，被正确地判断为阳性的样本比率。<br>TPR=TP/(TP+FN)<br>FPR：在所有实际为阴性的样本中，被错误地判断为阳性的样本比率。<br>FPR=FP/(FP+TN)<br>给定一个二分类模型和它的阈值，就可以根据所有测试集样本点的真实值和预测值计算出一个(X=FPR,Y=TPR)坐标点，使用单点绘图方法即可得到 ROC 曲线。 </font></font></p><p><font size="4">2.AUC：<font size="4"><br>AUC 的全称是 Area under the Curve of ROC，也就是 ROC 曲线下方的面积。在机器学习领域，经常用 AUC 值来评价一个二分类模型的训练效果。<br>AUC 被定义为 ROC 曲线下的面积，显然这个面积的数值不会大于 1。在检验模型时，AUC 值越大的模型，正确率越高。<br>例如：已经得出一系列样本被划分为正类的概率，按照大小排序，下图是一个示例，图中共有 20 个测试样本，“Class”一栏表示每个测试样本真正的标签（P 表示正样本，N 表示负样本），“Score”表示每个测试样本属于正样本的概率。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/Machine Learing ROC and AUC/2.png" alt="waitting"><br>接下来，从高到低依次将“Score”值作为阈值 threshold，当测试样本属于正样本的概率大于或等于这个 threshold 时，认为它为正样本，否则为负样本。举例来说，对于图中第 4 个样本，其“Score”值为 0.6，那么样本 1、2、3、4 都被认为是正样本，因为它们的“Score”值都大于等于 0.6，而其他样本则都认为是负样本。每次选取一个不同的 threshold，就可以得到一组 FPR 和 TPR，即 ROC 曲线上的一点。这样一来，一共得到了 20 组 FPR 和 TPR 的值，将它们画成 ROC 曲线的结果如下图：<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/Machine Learing ROC and AUC/3.png" alt="waitting"><br>AUC(Area under Curve)：ROC 曲线下的面积，介于 0.1 和 1 之间。AUC 作为数值可以直观地评价分类器的好坏，值越大越好。 </font></font></p><p><font size="4">3.sklearn计算ROC<font size="4"><br>sklearn给出了一个计算ROC的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y = np.array([1, 1, 2, 2])</span><br><span class="line">scores = np.array([0.1, 0.4, 0.35, 0.8])</span><br><span class="line">fpr, tpr, thresholds = metrics.roc_curve(y, scores, pos_label=2)</span><br></pre></td></tr></table></figure></font></font></p><p>通过计算，得到的结果（TPR, FPR, 截断点）为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fpr = array([ 0. ,  0.5,  0.5,  1. ])</span><br><span class="line">tpr = array([ 0.5,  0.5,  1. ,  1. ])</span><br><span class="line">thresholds = array([ 0.8 ,  0.4 ,  0.35,  0.1 ])#截断点</span><br></pre></td></tr></table></figure></p><p>将结果中的FPR与TPR画到二维坐标中，得到的ROC曲线如下（蓝色线条表示），ROC曲线的面积用AUC表示（淡黄色阴影部分）。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/Machine Learing ROC and AUC/4.png" alt="waitting"></p><p><font size="4">4.详细的计算过程<font size="4"><br>上例给出的数据如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y = np.array([1, 1, 2, 2])</span><br><span class="line">scores = np.array([0.1, 0.4, 0.35, 0.8])</span><br></pre></td></tr></table></figure></font></font></p><p>用这个数据，计算TPR，FPR的过程是怎么样的呢？<br>(1)分析数据<br>y是一个一维数组（样本的真实分类）。数组值表示类别（一共有两类，1和2）。我们假设y中的1表示反例，2表示正例。即将y重写为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y_true = [0, 0, 1, 1]</span><br></pre></td></tr></table></figure></p><p>score即各个样本属于正例的概率。</p><p>(2)针对score，将数据排序<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/Machine Learing ROC and AUC/5.png" alt="waitting"></p><p>(3)将截断点依次取为score值<br>将截断点依次取值为0.1,0.35,0.4,0.8时，计算TPR和FPR的结果。</p><p>1)截断点为0.1<br>说明只要score&gt;=0.1，它的预测类别就是正例。<br>此时，因为4个样本的score都大于等于0.1，所以，所有样本的预测类别都为P。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scores = [0.1, 0.4, 0.35, 0.8]</span><br><span class="line">y_true = [0, 0, 1, 1] </span><br><span class="line">y_pred = [1, 1, 1, 1]</span><br></pre></td></tr></table></figure></p><p><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/Machine Learing ROC and AUC/6.png" alt="waitting"><br>TPR = TP/(TP+FN) = 1<br>FPR = FP/(TN+FP) = 1</p><p>2)截断点为0.35<br>说明只要score&gt;=0.35，它的预测类别就是P。<br>此时，因为4个样本的score有3个大于等于0.35。所以，所有样本的预测类有3个为P（2个预测正确，1一个预测错误）；1个样本被预测为N（预测正确）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scores = [0.1, 0.4, 0.35, 0.8]</span><br><span class="line">y_true = [0, 0, 1, 1] </span><br><span class="line">y_pred = [0, 1, 1, 1]</span><br></pre></td></tr></table></figure></p><p><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/Machine Learing ROC and AUC/7.png" alt="waitting"><br>TPR = TP/(TP+FN) = 1<br>FPR = FP/(TN+FP) = 0.5</p><p>3)截断点为0.4<br>说明只要score&gt;=0.4，它的预测类别就是P。<br>此时，因为4个样本的score有2个大于等于0.4。所以，所有样本的预测类有2个为P（1个预测正确，1一个预测错误）；2个样本被预测为N（1个预测正确，1一个预测错误）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scores = [0.1, 0.4, 0.35, 0.8]</span><br><span class="line">y_true = [0, 0, 1, 1] </span><br><span class="line">y_pred = [0, 1, 0, 1]</span><br></pre></td></tr></table></figure></p><p><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/Machine Learing ROC and AUC/8.png" alt="waitting"><br>TPR = TP/(TP+FN) = 0.5<br>FPR = FP/(TN+FP) = 0.5</p><p>4)截断点为0.8<br>说明只要score&gt;=0.8，它的预测类别就是P。所以，所有样本的预测类有1个为P（1个预测正确）；3个样本被预测为N（2个预测正确，1一个预测错误）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scores = [0.1, 0.4, 0.35, 0.8]</span><br><span class="line">y_true = [0, 0, 1, 1] </span><br><span class="line">y_pred = [0, 0, 0, 1]</span><br></pre></td></tr></table></figure></p><p><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/Machine Learing ROC and AUC/9.png" alt="waitting"><br>TPR = TP/(TP+FN) = 0.5<br>FPR = FP/(TN+FP) = 0</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font size=&quot;3&quot;&gt;机器学习之ROC和AUC&lt;/font&gt;

&lt;p&gt;&lt;font size=&quot;4&quot;&gt;1.ROC：&lt;font size=&quot;4&quot;&gt;&lt;br&gt;在机器学习理论中，可用ROC曲线来分析二元分类模型。在二分类问题中，数据的标签通常用（0/1）来表示，在模型训练完成后进行
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ROS-Learning-Notes</title>
    <link href="http://yoursite.com/2019/06/01/ROS-Learning-Notes/"/>
    <id>http://yoursite.com/2019/06/01/ROS-Learning-Notes/</id>
    <published>2019-05-31T21:31:51.000Z</published>
    <updated>2019-06-01T08:19:22.709Z</updated>
    
    <content type="html"><![CDATA[<font size="3">ROS学习笔记</font><p>ROS的基本思想：无须改动就能够在不同的机器人上复用代码。基于此，我们就可以在不同的机器人上分享和复用已经实现的功能。</p><p>一、ROS文件系统级<br>1、与其他操作系统类似，一个ROS程序的不同组件要放在不同的文件夹下。这些文件夹是根据功能的不同来对文件进行组织的。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/ROS-Learning-Notes/8.png" alt="waitting"><br>(1)功能包(Package)：一个功能包具有创建ROS程序的最小结构和最少内容。一个package可包含ROS运行的进程（节点）、配置文件等。<br>(2)功能包清单(Package Manifest)：功能包清单提供关于功能包、许可关系、依赖关系、编译标志等信息。一个包的清单有一个名为package.xml的文件管理。<br>(3)元功能包(MetaPackage)：将几个具有某些功能的功能包组织在一起，就是一个元功能包。在ROS系统中，存在大量不同用途的元功能包，例如导航功能包集。<br>(4)元功能包清单(MetaPackage Manifest)：也由一个名为package.xml的文件管理，但有一个XML格式的导出标记。它在结构上有一定的限制。<br>(5)消息类型(Message(msg) type)：消息是一个进程发送到其他进程的信息。ROS系统中有很多的标准类型消息。消息类型的说明储存在my_package/msg/MyMessageType.msg中，也就是对应功能包的msg文件夹下。<br>(6)服务类型(Service(srv) type)：服务描述说明储存在my_package/srv/MySeviceType.srv中，定义了在ROS中由每个进程提供的关于服务请求和响应的数据结构。</p><p>2、工作空间<br>(1)源文件空间(source space)：在源空间(src)文件夹中，放置了功能包、项目、复制的包等。在这个空间中，最重要的一个文件是CMakeLists.txt。当在工作空间配置包时，src文件夹中的CMakeLists.txt会调用CMake。这个文件是通过catkin_init_workspace命令创建的。<br>(2)编译空间(build space)：在build文件夹中，CMake和catkin为功能包项目保存缓存信息、配置和其他中间文件。<br>(3)开发空间(development(devel) space)：在devel文件夹中，用来保存编译后的程序，这些是无需安装就能用来测试的程序。一旦项目通过测试，就可以安装或导出功能包从而与其他开发人员分享。</p><p>3、功能包：package<br>(1)功能包指的是一种特定结构的文件和文件夹组合。<br>(2)package的最精简结构(判断是否是一个package):<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/ROS-Learning-Notes/13.png" alt="waitting"></p><p>(3)package中的代码格式：<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/ROS-Learning-Notes/9.png" alt="waitting"></p><p>(4)package中的自定义通信格式：<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/ROS-Learning-Notes/10.png" alt="waitting"></p><p>(5)package的组成：<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/ROS-Learning-Notes/11.png" alt="waitting"></p><p>(6)package.xml<br>文件package.xml必须在每个功能包中，它用来说明此包相关的各类信息。打开一个package.xml文件，可以看到包的名称、依赖关系等信息。功能包清单的作用就是为了方便安装和分发这些功能包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#package.xml</span><br><span class="line">&lt;package&gt;</span><br><span class="line">&lt;name&gt;              #包名</span><br><span class="line">&lt;version&gt;           #版本号</span><br><span class="line">&lt;description&gt;       #包描述</span><br><span class="line">&lt;maintainer&gt;        #维护者</span><br><span class="line">&lt;license&gt;           #许可证 </span><br><span class="line">&lt;buildtool_depend&gt;  #编译工具</span><br><span class="line">&lt;build_depend&gt;      #编译时的依赖</span><br><span class="line">&lt;run_depend&gt;        #运行时的依赖</span><br><span class="line">&lt;/package&gt;</span><br></pre></td></tr></table></figure></p><p>在package.xml文件中两个典型的标记是&lt;build_depend&gt;和&lt;run_depend&gt;,&lt;build_depend&gt;标记会显示当前功能包安装之前必须先安装哪些功能包，因为新的功能包会使用其他包的一些功能。&lt;run_depend&gt;标记会显示运行功能包中代码所需要的包。</p><p>二、ROS计算图级：<br>1、ROS会创建一个连接到所有进程的网络，在系统中的任何一个节点都可以访问此网络，并通过该网络与其他节点交互，获取其他节点发送的消息，并将自身数据发布到网络上。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/ROS-Learning-Notes/12.png" alt="waitting"></p><p>2、节点：node<br>节点是主要的计算执行进程。如果想要有一个可以与其他节点进行交互的进程，那么需要创建一个节点，并将此节点连接到ROS网络。通常情况下，系统包含能够实现不同功能的多个节点。最好让众多节点都具有单一的功能，而不是在系统中创建一个包罗万象的大节点。<br>节点都是各自独立的可执行文件，能够通过主题、服务或参数服务器与其他进程（节点）通信。ROS通过使用节点将代码和功能解耦，提高了系统容错能力和可维护性，使系统简化。<br>节点在系统中必须有唯一的名称。节点使用特定名称与其他节点进行通信而不产生二义性。节点可以使用不同的库进行编写，如roscpp和rospy。roscpp基于C++，rospy基于python。<br>ROS提供了处理节点和显示节点信息的工具，如rosnode。rosnode是一个用于显示节点信息的命令行工具。支持的命令如下：</p><p><font size="4"><strong>·</strong></font>rosnode info NODE        输出当前节点信息</p><p><font size="4"><strong>·</strong></font>rosnode kill NODE        结束当前运行节点进程或发送给定信号</p><p><font size="4"><strong>·</strong></font>rosnode list             列出当前活动节点</p><p><font size="4"><strong>·</strong></font>rosnode machine hostname 列出某一特定计算机上运行的节点或列出主机名称</p><p><font size="4"><strong>·</strong></font>rosnode ping NODE        测试节点间的连通性</p><p><font size="4"><strong>·</strong></font>rosnode cleanup          将无法访问节点的注册信息删除</p><p>3、主题：topic<br>每个消息都必须有一个名称以便被ROS网络分发。当一个节点发送数据时，我们就说该节点正在向主题发布消息。节点可以通过订阅某个主题，接收来自其他节点的消息。一个节点可以订阅一个主题，而不需要任何其他节点同时发布该主题，这就保证了消息的发布者和订阅者之间的解耦，完全无须知道对方的存在。主题的名称必须是唯一的，否则在同名主题之间的消息路由就会发生错误。<br>主题是节点间用来传输数据的总线。通过主题进行消息传输不需要节点之间连接。这就意味着发布者和订阅者之间不需要知道彼此是否存在。一个主题可以有多个订阅者，也可以有多个发布者，但是用不同的节点发布同样的主题时要慎重，否则会产生冲突。<br>每个主题都是强类型的，发布到主题上的消息必须与主题的ROS消息类型相匹配，并且节点只能接收类型匹配的消息。节点想要订阅主题，就必须具有相同的类型。<br>ROS的主题可以使用TCP/IP和UDP传输。基于TCP传输称为TCPROS，它使用TCP/IP长连接，这时ROS默认的传输方式。基于UDP传输称为UDPROS，它是一种低延迟高效率的传输方式，但可能产生数据丢失，所以它最适合于像远程操控的任务。<br>ROS有一个rostopic工具用于主题操作，它是一个命令行工具，允许我们获取主题的相关信息或直接在网络上发布数据。支持的命令如下：</p><p><font size="4"><strong>·</strong></font>rostopic bw /topic            显示主题所使用的宽带</p><p><font size="4"><strong>·</strong></font>rostopic echo /topic          将消息输出到屏幕</p><p><font size="4"><strong>·</strong>/font&gt;rostopic find message_type    按照类型查找主题</font></p><p><font size="4"><strong>·</strong></font>rostopic hz /topic            显示主题的发布频率</p><p><font size="4"><strong>·</strong></font>rostopic info /topic          输出主题的信息，例如其消息类型、发布者、订阅者</p><p><font size="4"><strong>·</strong></font>rostopic list                 输出活动的主题</p><p><font size="4"><strong>·</strong></font>rostopic pub /topic type args 将数据发布到主题，它允许我们直接从命令行中对任意主题创建和发布数据</p><p><font size="4"><strong>·</strong></font>rostopic type /topic          输出主题的类型，即主题中发布的消息类型</p><p>4、服务：service</p><p>5、消息：message</p><p>6、节点管理器</p><p>7、参数服务器</p><p>三、ROS-Academy-for-Beginners命令演示<br>1、启动gazebo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch robot_sim_demo robot_spawn.launch</span><br></pre></td></tr></table></figure></p><p><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/ROS-Learning-Notes/1.png" alt="waitting"></p><p>2、启动键盘控制机器人移动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun robot_sim_demo robot_keyboard_teleop.py</span><br></pre></td></tr></table></figure></p><p><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/ROS-Learning-Notes/2.png" alt="waitting"></p><p>3、启动rgb摄像头<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun image_view image_view image:=/camera/rgb/image_raw</span><br></pre></td></tr></table></figure></p><p><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/ROS-Learning-Notes/3.png" alt="waitting"></p><p>4、启动深度摄像头<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun image_view image_view image:=/camera/depth/image_raw</span><br></pre></td></tr></table></figure></p><p><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/ROS-Learning-Notes/4.png" alt="waitting"></p><p>5、启动navigation模拟<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch navigation_sim_demo amcl_demo.launch</span><br></pre></td></tr></table></figure></p><p><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/ROS-Learning-Notes/6.png" alt="waitting"></p><p>6、启动rviz，显示建立好的地图<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch navigation_dim_demo view_navigation.launch</span><br></pre></td></tr></table></figure></p><p><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/ROS-Learning-Notes/7.png" alt="waitting"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font size=&quot;3&quot;&gt;ROS学习笔记&lt;/font&gt;

&lt;p&gt;ROS的基本思想：无须改动就能够在不同的机器人上复用代码。基于此，我们就可以在不同的机器人上分享和复用已经实现的功能。&lt;/p&gt;
&lt;p&gt;一、ROS文件系统级&lt;br&gt;1、与其他操作系统类似，一个ROS程序的不同组件要
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Machine-Learning-Vectorization</title>
    <link href="http://yoursite.com/2019/05/21/Machine-Learning-Vectorization/"/>
    <id>http://yoursite.com/2019/05/21/Machine-Learning-Vectorization/</id>
    <published>2019-05-21T09:09:32.000Z</published>
    <updated>2019-05-31T21:36:39.695Z</updated>
    
    <content type="html"><![CDATA[<font size="3">大数据挑战赛:机器学习之域名向量化</font><p>使用字符嵌入模型(Character Embedding)完成域名的向量化Character Embedding 方法将每个单独字符视为一个特征，根据这个规则对所有域名的特征进行提取、去重，结果作为所有域名具有的特征。每个特征都对应着一个索引，对于域名中的每个字符，都用对应的特征索引进行替代，从而得到域名的索引表示。随后将其输入Embedding网络层，输出的向量就是域名的向量表示。</p><p>话不多说，直接在命令行中演示:<br>1、现随便给出几个个域名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; domains = [&apos;jobhero-com-1.disqus.com&apos;, &apos;vstu.by&apos;, &apos;diamondpeak.com&apos;, &apos;netcollections.net&apos;, &apos;pfgc.com.s7a1.psmtp.com&apos;, &apos;dudeiwantthat.com&apos;, &apos;sascha-frank.com&apos;, &apos;milavia.net&apos;]</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; domains</span><br><span class="line">[&apos;jobhero-com-1.disqus.com&apos;, &apos;vstu.by&apos;, &apos;diamondpeak.com&apos;, &apos;netcollections.net&apos;, </span><br><span class="line">&apos;pfgc.com.s7a1.psmtp.com&apos;, &apos;dudeiwantthat.com&apos;, &apos;sascha-frank.com&apos;, &apos;milavia.net&apos;]</span><br></pre></td></tr></table></figure><p>2、<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from sklearn import feature_extraction</span><br></pre></td></tr></table></figure></p><p>3、分割字符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ngram_vectorizer = feature_extraction.text.CountVectorizer(analyzer=&apos;char&apos;, ngram_range=(2, 2))               </span><br><span class="line">&gt;&gt;&gt; count_vec = ngram_vectorizer.fit_transform(domains) </span><br><span class="line"></span><br><span class="line">analyzer=‘char’表示以字符串的方式将数据块化，ngram_range=(2, 2)表示每两个字符进行分割，下面为输出示例：</span><br></pre></td></tr></table></figure></p><p>4、将domains以每两个字符进行分割，以列表形式展现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(ngram_vectorizer.get_feature_names())</span><br><span class="line">[&apos;-1&apos;, &apos;-c&apos;, &apos;-f&apos;, &apos;.b&apos;, &apos;.c&apos;, &apos;.d&apos;, &apos;.n&apos;, &apos;.p&apos;, &apos;.s&apos;, &apos;1.&apos;, &apos;7a&apos;, &apos;a-&apos;, &apos;a.&apos;, </span><br><span class="line">&apos;a1&apos;, &apos;ak&apos;, &apos;am&apos;, &apos;an&apos;, &apos;as&apos;, &apos;at&apos;, &apos;av&apos;, &apos;bh&apos;, &apos;by&apos;, &apos;c.&apos;, &apos;ch&apos;, &apos;co&apos;, &apos;ct&apos;, </span><br><span class="line">&apos;de&apos;, &apos;di&apos;, &apos;dp&apos;, &apos;du&apos;, &apos;ea&apos;, &apos;ec&apos;, &apos;ei&apos;, &apos;er&apos;, &apos;et&apos;, &apos;fg&apos;, &apos;fr&apos;, &apos;gc&apos;, &apos;ha&apos;, </span><br><span class="line">&apos;he&apos;, &apos;ia&apos;, &apos;il&apos;, &apos;io&apos;, &apos;is&apos;, &apos;iw&apos;, &apos;jo&apos;, &apos;k.&apos;, &apos;la&apos;, &apos;le&apos;, &apos;ll&apos;, &apos;m-&apos;, &apos;m.&apos;, </span><br><span class="line">&apos;mi&apos;, &apos;mo&apos;, &apos;mt&apos;, &apos;nd&apos;, &apos;ne&apos;, &apos;nk&apos;, &apos;ns&apos;, &apos;nt&apos;, &apos;o-&apos;, &apos;ob&apos;, &apos;ol&apos;, &apos;om&apos;, &apos;on&apos;, </span><br><span class="line">&apos;p.&apos;, &apos;pe&apos;, &apos;pf&apos;, &apos;ps&apos;, &apos;qu&apos;, &apos;ra&apos;, &apos;ro&apos;, &apos;s.&apos;, &apos;s7&apos;, &apos;sa&apos;, &apos;sc&apos;, &apos;sm&apos;, &apos;sq&apos;, </span><br><span class="line">&apos;st&apos;, &apos;t.&apos;, &apos;tc&apos;, &apos;th&apos;, &apos;ti&apos;, &apos;tp&apos;, &apos;tt&apos;, &apos;tu&apos;, &apos;u.&apos;, &apos;ud&apos;, &apos;us&apos;, &apos;vi&apos;, &apos;vs&apos;, &apos;wa&apos;]</span><br></pre></td></tr></table></figure></p><p>5、以字典形式展现，key：分割的字符   value：索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(ngram_vectorizer.vocabulary_)</span><br><span class="line">&#123;&apos;jo&apos;: 45, &apos;ob&apos;: 61, &apos;bh&apos;: 20, &apos;he&apos;: 39, &apos;er&apos;: 33, &apos;ro&apos;: 71, &apos;o-&apos;: 60, &apos;-c&apos;: </span><br><span class="line">1, &apos;co&apos;: 24, &apos;om&apos;: 63, &apos;m-&apos;: 50, &apos;-1&apos;: 0, &apos;1.&apos;: 9, &apos;.d&apos;: 5, &apos;di&apos;: 27, &apos;is&apos;: </span><br><span class="line">43, &apos;sq&apos;: 77, &apos;qu&apos;: 69, &apos;us&apos;: 88, &apos;s.&apos;: 72, &apos;.c&apos;: 4, &apos;vs&apos;: 90, &apos;st&apos;: 78, &apos;tu&apos;: </span><br><span class="line">85, &apos;u.&apos;: 86, &apos;.b&apos;: 3, &apos;by&apos;: 21, &apos;ia&apos;: 40, &apos;am&apos;: 15, &apos;mo&apos;: 53, &apos;on&apos;: 64, &apos;nd&apos;: </span><br><span class="line">55, &apos;dp&apos;: 28, &apos;pe&apos;: 66, &apos;ea&apos;: 30, &apos;ak&apos;: 14, &apos;k.&apos;: 46, &apos;ne&apos;: 56, &apos;et&apos;: 34, &apos;tc&apos;: </span><br><span class="line">80, &apos;ol&apos;: 62, &apos;ll&apos;: 49, &apos;le&apos;: 48, &apos;ec&apos;: 31, &apos;ct&apos;: 25, &apos;ti&apos;: 82, &apos;io&apos;: 42, &apos;ns&apos;: </span><br><span class="line">58, &apos;.n&apos;: 6, &apos;pf&apos;: 67, &apos;fg&apos;: 35, &apos;gc&apos;: 37, &apos;c.&apos;: 22, &apos;m.&apos;: 51, &apos;.s&apos;: 8, &apos;s7&apos;: </span><br><span class="line">73, &apos;7a&apos;: 10, &apos;a1&apos;: 13, &apos;.p&apos;: 7, &apos;ps&apos;: 68, &apos;sm&apos;: 76, &apos;mt&apos;: 54, &apos;tp&apos;: 83, &apos;p.&apos;: </span><br><span class="line">65, &apos;du&apos;: 29, &apos;ud&apos;: 87, &apos;de&apos;: 26, &apos;ei&apos;: 32, &apos;iw&apos;: 44, &apos;wa&apos;: 91, &apos;an&apos;: 16, &apos;nt&apos;: </span><br><span class="line">59, &apos;tt&apos;: 84, &apos;th&apos;: 81, &apos;ha&apos;: 38, &apos;at&apos;: 18, &apos;t.&apos;: 79, &apos;sa&apos;: 74, &apos;as&apos;: 17, &apos;sc&apos;: </span><br><span class="line">75, &apos;ch&apos;: 23, &apos;a-&apos;: 11, &apos;-f&apos;: 2, &apos;fr&apos;: 36, &apos;ra&apos;: 70, &apos;nk&apos;: 57, &apos;mi&apos;: 52, &apos;il&apos;: </span><br><span class="line">41, &apos;la&apos;: 47, &apos;av&apos;: 19, &apos;vi&apos;: 89, &apos;a.&apos;: 12&#125;</span><br></pre></td></tr></table></figure></p><p>6、<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(count_vec)</span><br><span class="line">  (0, 4)        1      (第0个domains列表元素，词典中索引为 4的元素)， 词频</span><br><span class="line">  (0, 72)       1      (第0个domains列表元素，词典中索引为72的元素)， 词频</span><br><span class="line">  (0, 88)       1      (第0个domains列表元素，词典中索引为88的元素)， 词频</span><br><span class="line">  (0, 69)       1</span><br><span class="line">  (0, 77)       1</span><br><span class="line">  (0, 43)       1</span><br><span class="line">  (0, 27)       1</span><br><span class="line">  (0, 5)        1</span><br><span class="line">  (0, 9)        1</span><br><span class="line">  (0, 0)        1</span><br><span class="line">  (0, 50)       1</span><br><span class="line">  (0, 63)       2</span><br><span class="line">  (0, 24)       2</span><br><span class="line">  (0, 1)        1</span><br><span class="line">  (0, 60)       1</span><br><span class="line">  (0, 71)       1</span><br><span class="line">  (0, 33)       1</span><br><span class="line">  (0, 39)       1</span><br><span class="line">  (0, 20)       1</span><br><span class="line">  (0, 61)       1</span><br><span class="line">  (0, 45)       1</span><br><span class="line">  (1, 21)       1</span><br><span class="line">  (1, 3)        1</span><br><span class="line">  (1, 86)       1</span><br><span class="line">  (1, 85)       1</span><br><span class="line">  :     :</span><br><span class="line">  (6, 57)       1</span><br><span class="line">  (6, 70)       1</span><br><span class="line">  (6, 36)       1</span><br><span class="line">  (6, 2)        1</span><br><span class="line">  (6, 11)       1</span><br><span class="line">  (6, 23)       1</span><br><span class="line">  (6, 75)       1</span><br><span class="line">  (6, 17)       1</span><br><span class="line">  (6, 74)       1</span><br><span class="line">  (6, 38)       1</span><br><span class="line">  (6, 16)       1</span><br><span class="line">  (6, 46)       1</span><br><span class="line">  (6, 4)        1</span><br><span class="line">  (6, 63)       1</span><br><span class="line">  (6, 24)       1</span><br><span class="line">  (7, 12)       1</span><br><span class="line">  (7, 89)       1</span><br><span class="line">  (7, 19)       1</span><br><span class="line">  (7, 47)       1</span><br><span class="line">  (7, 41)       1</span><br><span class="line">  (7, 52)       1</span><br><span class="line">  (7, 6)        1</span><br><span class="line">  (7, 34)       1</span><br><span class="line">  (7, 56)       1</span><br><span class="line">  (7, 40)       1</span><br></pre></td></tr></table></figure></p><p>7、将结果转化为矩阵的表示方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(count_vec.toarray())</span><br><span class="line">[[1 1 0 0 1 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 2 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 1 0 1 </span><br><span class="line">0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 1 0 2 0 0 0 0 0 1 0 1 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0]                                                                         </span><br><span class="line">[0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 </span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 1 0 0 0 1 0]</span><br><span class="line">[0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 1 0 0 1 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 </span><br><span class="line">1 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]</span><br><span class="line">[0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 1 0 0 2 0 0 0 0 0 0 0 1 0 0 0 </span><br><span class="line">0 0 1 1 0 0 0 0 0 0 2 0 1 0 0 0 1 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0]</span><br><span class="line">[0 0 0 0 2 0 0 1 1 1 1 0 0 1 0 0 0 0 0 0 0 0 1 0 2 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 </span><br><span class="line">0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 2 0 1 0 1 1 0 0 0 0 1 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0]</span><br><span class="line">[0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 1 0 1 0 0 1 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0 </span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 1 0 0 1 0 0 0 1]</span><br><span class="line">[0 0 1 0 1 0 0 0 0 0 0 1 0 0 0 0 1 1 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 </span><br><span class="line">1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]                                                                         </span><br><span class="line">[0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 1 0 0 0 0 </span><br><span class="line">0 1 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0]]</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font size=&quot;3&quot;&gt;大数据挑战赛:机器学习之域名向量化&lt;/font&gt;

&lt;p&gt;使用字符嵌入模型(Character Embedding)完成域名的向量化Character Embedding 方法将每个单独字符视为一个特征，根据这个规则对所有域名的特征进行提取、去重，结
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PCL-Learning-Notes</title>
    <link href="http://yoursite.com/2019/05/18/PCL-Learning-Notes/"/>
    <id>http://yoursite.com/2019/05/18/PCL-Learning-Notes/</id>
    <published>2019-05-18T02:12:22.000Z</published>
    <updated>2019-05-31T15:57:29.088Z</updated>
    
    <content type="html"><![CDATA[<font size="3">点云库(PCL:Point Cloud Library)学习笔记</font><p>1、了解名词<br>(1)点云：通过测量仪器得到的产品外观表面的点数据集合称之为点云，使用三维激光扫描仪或照相式扫描仪得到的点云，点数量比较大并且比较密集，叫密集点云。</p><p>点云是在和目标表面特性的海量点集合。<br>根据激光测量原理得到的点云，包括三维坐标(XYZ)和激光反射强度(Intensity)。<br>根据摄影测量原理得到的点云，包括三维坐标(XYZ)和颜色信息(RGB)。<br>结合激光测量和摄影测量原理得到点云，包括三维坐标(XYZ)、激光反射强度(Intensity)和颜色信息(RGB)。<br>在获取物体表面每个采样点的空间坐标后，得到的是一个点的集合，称之为“点云”(Point Cloud)。</p><p>当一束激光照射到物体表面时，所反射的激光会携带方位、距离等信息。若将激光束按照某种轨迹进行扫描，便会边扫描边记录到反射的激光点信息，由于扫描极为精细，则能够得到大量的激光点，因而就可形成激光点云。</p><p>(2)SLAM，即时定位与制图，包含3个关键词：实时、定位、制图，就是实时完成定位和制图的任务，这就是SLAM要解决的基本任务。按照使用的传感器分为<br>激光SLAM（LOAM、V-LOAM、cartographer）与视觉SLAM，其中视觉SLAM又可分为<br>单目SLAM（MonoSLAM、PTAM、DTAM、LSD-SLAM、ORB-SLAM（单目为主）、SVO）、双目SLAM（LIBVISO2、S-PTAM等）、<br>RGBD SLAM（KinectFusion、ElasticFusion、Kintinous、RGBD SLAM2、RTAB SLAM）；<br>视觉SLAM由前端（视觉里程计）、后端（位姿优化）、闭环检测、制图4个部分组成。</p><p>(3)Kinect RGB-D摄像机包含三个镜头，一个彩色摄像头，一个红外发射器和一个红外线CMOS摄像头。其中彩色摄像头可以获取彩色图像，红外线发射器和红外线CMOS摄像头共同组成了三维深度传感器。使用Kinect可以得到一副RGB图像和与之对应的深度图像，两种图像可以合成点云图。</p><p>2、kinect标定<br>视觉SLAM中通过相机模型来生成三维点云数据，需要对Kinect进行标定。Kinetc能同时获取彩色图像和深度图像，需要分别对两种图像进行标定。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/PCL-Learning-Notes/pcl-1.png" alt="waitting"><br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/PCL-Learning-Notes/pcl-2.png" alt="waitting"><br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/PCL-Learning-Notes/pcl-3.png" alt="waitting"></p><p>3、点线特征提取</p><p>(1)基于点线特征的三维地图构建算法主要包含三个模块：前端视觉里程计、后端优化和闭环优化。视觉里程计实时处理视频流，通过点线特征匹配求解相机的当前位姿；后端优化维护局部地图并对视觉里程计估计的初始位姿进行局部优化；闭环优化在检测到闭环后，通过闭环校正和全局优化得到全局一致的轨迹和地图。(视觉里程计：视觉里程计（VO），它根据相邻图像的信息粗略的估计出相机的运动，给后端提供较好的初始值。VO的实现方法可以根据是否需要提取特征分为两类：基于特征点的方法，不使用特征点的直接方法。 基于特征点的VO运行稳定，对光照、动态物体不敏感。)</p><p>(2)点特征提取<br>1)FAST特征点提取算法<br>FAST算法的思想很简单：如果一个像素与周围邻域的像素差别较大（过亮或者过暗），那么可以认为该像素是一个角点。和其他的特征点提取算法相比，FAST算法只需要比较像素和其邻域像素的灰度值大小，十分便捷。<br>FAST算法提取角点的步骤：<br><strong><font size="3">·</font></strong>在图像中选择像素p，假设其灰度值为：Ip<br><strong><font size="3">·</font></strong>设置一个阈值T，例如：Ip的20%<br><strong><font size="3">·</font></strong>选择p周围半径为3的圆上的16个像素，作为比较像素<br><strong><font size="3">·</font></strong>假设选取的圆上有连续的N个像素大于Ip+T或者Ip−T，那么可以认为像素p就是一个特征点。（N通常取12，即为FAST-12；常用的还有FAST-9,FAST-11）。FAST算法只检测像素的灰度值，其运算速度极快，同时不可避免的也有一些缺点。<br><strong><font size="3">·</font></strong>检测到的特征点过多并且会出现“扎堆”的现象。这可以在第一遍检测完成后，使用非最大值抑制（Non-maximal suppression），在一定区域内仅保留响应极大值的角点，避免角点集中的情况。<br><strong><font size="3">·</font></strong>FAST提取到的角点没有方向和尺度信息。</p><p>2)BRIEF描述子<br>BRIEF是一种二进制的描述子，其描述向量是0和1表示的二进制串。0和1表示特征点邻域内两个像素（p和q）灰度值的大小：如果p比q大则选择1，反正就取0。在特征点的周围选择128对这样的p和q的像素对，就得到了128维由0，1组成的向量。那么p和q的像素对是怎么选择的呢？通常都是按照某种概率来随机的挑选像素对的位置。<br>BRIEF使用随机选点的比较，速度很快，而且使用二进制串表示最终生成的描述子向量，在存储以及用于匹配的比较时都是非常方便的，其和FAST的搭配起来可以组成非常快速的特征点提取和描述算法。</p><p>3)ORB算法<br>ORB是目前来说非常好的能够进行的实时的图像特征提取和描述的算法，它改进了FAST特征提取算法，并使用速度极快的二进制描述子BRIEF。针对FAST特征提取的算法的一些缺点，ORB也做了相应的改进。<br><strong><font size="3">·</font></strong>使用非最大值抑制，在一定区域内仅仅保留响应极大值的角点，避免FAST提取到的角点过于集中。<br><strong><font size="3">·</font></strong>FAST提取到的角点数量过多且不是很稳定，ORB中可以指定需要提取到的角点的数量N，然后对FAST提取到的角点分别计算Harris响应值，选择前N个具有最大响应值的角点作为最终提取到的特征点集合。<br><strong><font size="3">·</font></strong>FAST提取到的角点不具有尺度信息，在ORB中使用图像金字塔，并且在每一层金字塔上检测角点，以此来保持尺度的不变性。<br><strong><font size="3">·</font></strong>FAST提取到的角点不具有方向信息，在ORB中使用灰度质心法(Intensity Centroid)来保持特征的旋转不变性。</p><p>4)OpenCV3中特征点的提取和匹配<br>OpenCV中封装了常用的特征点算法（如SIFT,SURF，ORB等），提供了统一的接口，便于调用。 下面代码是OpenCV中使用其feature 2D 模块的示例代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Mat img1 = imread(&quot;F:\\image\\1.png&quot;);</span><br><span class="line">Mat img2 = imread(&quot;F:\\image\\2.png&quot;);</span><br><span class="line"></span><br><span class="line">// 1. 初始化</span><br><span class="line">vector&lt;KeyPoint&gt; keypoints1, keypoints2;</span><br><span class="line">Mat descriptors1, descriptors2;</span><br><span class="line">Ptr&lt;ORB&gt; orb = ORB::create();</span><br><span class="line"></span><br><span class="line">// 2. 提取特征点</span><br><span class="line">orb-&gt;detect(img1, keypoints1);</span><br><span class="line">orb-&gt;detect(img2, keypoints2);</span><br><span class="line"></span><br><span class="line">// 3. 计算特征描述符</span><br><span class="line">orb-&gt;compute(img1, keypoints1, descriptors1);</span><br><span class="line">orb-&gt;compute(img2, keypoints2, descriptors2);</span><br><span class="line">    </span><br><span class="line">// 4. 对两幅图像的BRIEF描述符进行匹配，使用BFMatch，Hamming距离作为参考</span><br><span class="line">vector&lt;DMatch&gt; matches;</span><br><span class="line">BFMatcher bfMatcher(NORM_HAMMING);</span><br><span class="line">bfMatcher.match(descriptors1, descriptors2, matches);</span><br></pre></td></tr></table></figure></p><p><strong><font size="3">·</font></strong>在OpenCV3中重新的封装了特征提取的接口，可统一的使用Ptr<featuredetector> detector = FeatureDetector::create()来得到特征提取器的一个实例，所有的参数都提供了默认值，也可以根据具体的需要传入相应的参数。<br><strong><font size="3">·</font></strong>在得到特征检测器的实例后，可调用的detect方法检测图像中的特征点的具体位置，检测的结果保存在vector<keypoint>向量中。<br><strong><font size="3">·</font></strong>有了特征点的位置后，调用compute方法来计算特征点的描述子，描述子通常是一个向量，保存在Mat中。<br><strong><font size="3">·</font></strong>得到了描述子后，可调用匹配算法进行特征点的匹配。上面代码中，使用了opencv中封装后的暴力匹配算法BFMatcher，该算法在向量空间中，将特征点的描述子一一比较，选择距离（上面代码中使用的是Hamming距离）较小的一对作为匹配点。<br>上面代码匹配后的结果如下：<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/PCL-Learning-Notes/pcl-4.jpg" alt="waitting"><br>特征点的匹配后的优化:<br>特征的匹配是针对特征描述子的进行的，上面提到特征描述子通常是一个向量，两个特征描述子的之间的距离可以反应出其相似的程度，也就是这两个特征点是不是同一个。根据描述子的不同，可以选择不同的距离度量。如果是浮点类型的描述子，可以使用其欧式距离；对于二进制的描述子（BRIEF）可以使用其汉明距离（两个不同二进制之间的汉明距离指的是两个二进制串不同位的个数）。</keypoint></featuredetector></p><p>有了计算描述子相似度的方法，那么在特征点的集合中如何寻找和其最相似的特征点，这就是特征点的匹配了。最简单直观的方法就是上面使用的：暴力匹配方法(Brute-Froce Matcher)，计算某一个特征点描述子与其他所有特征点描述子之间的距离，然后将得到的距离进行排序，取距离最近的一个作为匹配点。这种方法简单粗暴，其结果也是显而易见的，通过上面的匹配结果，也可以看出有大量的错误匹配，这就需要使用一些机制来过滤掉错误的匹配。</p><p><strong><font size="3">·</font></strong>汉明距离小于最小距离的两倍:选择已经匹配的点对的汉明距离小于最小距离的两倍作为判断依据，如果小于该值则认为是一个错误的匹配，过滤掉；大于该值则认为是一个正确的匹配。其实现代码也很简单，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 匹配对筛选</span><br><span class="line">double min_dist = 1000, max_dist = 0;</span><br><span class="line">// 找出所有匹配之间的最大值和最小值</span><br><span class="line">for (int i = 0; i &lt; descriptors1.rows; i++)</span><br><span class="line">&#123;</span><br><span class="line">double dist = matches[i].distance;</span><br><span class="line">    if (dist &lt; min_dist) min_dist = dist;</span><br><span class="line">    if (dist &gt; max_dist) max_dist = dist;</span><br><span class="line">&#125;</span><br><span class="line">// 当描述子之间的匹配大于2倍的最小距离时，即认为该匹配是一个错误的匹配。</span><br><span class="line">// 但有时描述子之间的最小距离非常小，可以设置一个经验值作为下限</span><br><span class="line">vector&lt;DMatch&gt; good_matches;</span><br><span class="line">for (int i = 0; i &lt; descriptors1.rows; i++)</span><br><span class="line">&#123;</span><br><span class="line">    if (matches[i].distance &lt;= max(2 * min_dist, 30.0))</span><br><span class="line">    good_matches.push_back(matches[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果如下：<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/PCL-Learning-Notes/pcl-5.jpg" alt="waitting"><br>对比只是用暴力匹配的方法，进行过滤后的匹配效果好了很多。</p><p><strong><font size="3">·</font></strong>交叉匹配<br>针对暴力匹配，可以使用交叉匹配的方法来过滤错误的匹配。交叉过滤的是想很简单，再进行一次匹配，反过来使用被匹配到的点进行匹配，如果匹配到的仍然是第一次匹配的点的话，就认为这是一个正确的匹配。举例来说就是，假如第一次特征点A使用暴力匹配的方法，匹配到的特征点是特征点B；反过来，使用特征点B进行匹配，如果匹配到的仍然是特征点A，则就认为这是一个正确的匹配，否则就是一个错误的匹配。OpenCV中BFMatcher已经封装了该方法，创建BFMatcher的实例时，第二个参数传入true即可，BFMatcher bfMatcher(NORM_HAMMING,true)。</p><p><strong><font size="3">·</font></strong>KNN匹配<br>K近邻匹配，在匹配的时候选择K个和特征点最相似的点，如果这K个点之间的区别足够大，则选择最相似的那个点作为匹配点，通常选择K = 2，也就是最近邻匹配。对每个匹配返回两个最近邻的匹配，如果第一匹配和第二匹配距离比率足够大（向量距离足够远），则认为这是一个正确的匹配，比率的阈值通常在2左右。OpenCV中的匹配器中封装了该方法，上面的代码可以调用bfMatcher-&gt;knnMatch(descriptors1, descriptors2, knnMatches, 2);具体实现的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const float minRatio = 1.f / 1.5f;</span><br><span class="line">const int k = 2;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;DMatch&gt;&gt; knnMatches;</span><br><span class="line">matcher-&gt;knnMatch(leftPattern-&gt;descriptors, rightPattern-&gt;descriptors, knnMatches, k);</span><br><span class="line"></span><br><span class="line">for (size_t i = 0; i &lt; knnMatches.size(); i++) &#123;</span><br><span class="line">const DMatch&amp; bestMatch = knnMatches[i][0];</span><br><span class="line">const DMatch&amp; betterMatch = knnMatches[i][1];</span><br><span class="line"></span><br><span class="line">float  distanceRatio = bestMatch.distance / betterMatch.distance;</span><br><span class="line">if (distanceRatio &lt; minRatio)</span><br><span class="line">            matches.push_back(bestMatch);</span><br><span class="line">&#125;const  float minRatio =  1.f  /  1.5f;</span><br><span class="line">const  int k =  2;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;DMatch&gt;&gt; knnMatches;</span><br><span class="line">matcher-&gt;knnMatch(leftPattern-&gt;descriptors, rightPattern-&gt;descriptors, knnMatches, 2);</span><br><span class="line"></span><br><span class="line">for (size_t i =  0; i &lt; knnMatches.size(); i++) &#123;</span><br><span class="line">    const DMatch&amp; bestMatch = knnMatches[i][0];</span><br><span class="line">    const DMatch&amp; betterMatch = knnMatches[i][1];</span><br><span class="line">    float distanceRatio = bestMatch.distance  / betterMatch.distance;</span><br><span class="line">    if (distanceRatio &lt; minRatio)</span><br><span class="line">            matches.push_back(bestMatch);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>将不满足的最近邻的匹配之间距离比率大于设定的阈值（1/1.5）匹配剔除。</p><p><strong><font size="3">·</font></strong>RANSAC:另外还可采用随机采样一致性（RANSAC）来过滤掉错误的匹配，该方法利用匹配点计算两个图像之间单应矩阵，然后利用重投影误差来判定某一个匹配是不是正确的匹配。OpenCV中封装了求解单应矩阵的方法findHomography,可以为该方法设定一个重投影误差的阈值，可以得到一个向量mask来指定那些是符合该重投影误差的匹配点对，以此来剔除错误的匹配，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">const int minNumbermatchesAllowed = 8;</span><br><span class="line">if (matches.size() &lt; minNumbermatchesAllowed)</span><br><span class="line">    return;</span><br><span class="line"></span><br><span class="line">//Prepare data for findHomography</span><br><span class="line">vector&lt;Point2f&gt; srcPoints(matches.size());</span><br><span class="line">vector&lt;Point2f&gt; dstPoints(matches.size());</span><br><span class="line"></span><br><span class="line">for (size_t i = 0; i &lt; matches.size(); i++) &#123;</span><br><span class="line">    srcPoints[i] = rightPattern-&gt;keypoints[matches[i].trainIdx].pt;</span><br><span class="line">    dstPoints[i] = leftPattern-&gt;keypoints[matches[i].queryIdx].pt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//find homography matrix and get inliers mask</span><br><span class="line">vector&lt;uchar&gt; inliersMask(srcPoints.size());</span><br><span class="line">homography = findHomography(srcPoints, dstPoints, CV_FM_RANSAC, reprojectionThreshold, inliersMask);</span><br><span class="line"></span><br><span class="line">vector&lt;DMatch&gt; inliers;</span><br><span class="line">for (size_t i = 0; i &lt; inliersMask.size(); i++)&#123;</span><br><span class="line">    if (inliersMask[i])</span><br><span class="line">        inliers.push_back(matches[i]);</span><br><span class="line">&#125;</span><br><span class="line">matches.swap(inliers);const  int minNumbermatchesAllowed =  8;</span><br><span class="line">if (matches.size() &lt; minNumbermatchesAllowed)</span><br><span class="line">    return;</span><br><span class="line"></span><br><span class="line">//Prepare data for findHomography</span><br><span class="line">vector&lt;Point2f&gt;  srcPoints(matches.size());</span><br><span class="line">vector&lt;Point2f&gt;  dstPoints(matches.size());</span><br><span class="line"></span><br><span class="line">for (size_t i =  0; i &lt; matches.size(); i++) &#123;</span><br><span class="line">    srcPoints[i] = rightPattern-&gt;keypoints[matches[i].trainIdx].pt;</span><br><span class="line">    dstPoints[i] = leftPattern-&gt;keypoints[matches[i].queryIdx].pt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//find homography matrix and get inliers mask</span><br><span class="line">vector&lt;uchar&gt;  inliersMask(srcPoints.size());</span><br><span class="line">homography =  findHomography(srcPoints, dstPoints, CV_FM_RANSAC, reprojectionThreshold, inliersMask);</span><br><span class="line"></span><br><span class="line">vector&lt;DMatch&gt; inliers;</span><br><span class="line">for (size_t i =  0; i &lt; inliersMask.size(); i++)&#123;</span><br><span class="line">    if (inliersMask[i])</span><br><span class="line">        inliers.push_back(matches[i]);</span><br><span class="line">&#125;</span><br><span class="line">matches.swap(inliers);</span><br></pre></td></tr></table></figure></p><p>(3)线特征提取</p><p>4、前端视觉里程计位姿估计</p><p>5、后端优化<br>视觉里程计能够增量式地构建环境地图，但其只考虑相邻之间位姿关系，长时间运行不可避免会产生累计误差，这样得到的地图是不准确的。后端优化环节把当前帧与更早的帧关联起来，加入更多的地图数据进行优化，从而降低累计误差。<br>视觉SLAM中会有成千上万帧图像，后端优化并不会耗费巨大的计算量将每一帧都纳入优化，因此需要选择一些有代表性的帧作为关键帧。同时，为了便于后续跟踪，需要尽可能快速插入关键帧。</p><p>6、八叉树地图的构建<br>点云地图是一种较为初级的地图表达方式，不能直接用于机器人的导航。八叉树地图中的每个节点表示一个立方体所包含的空间，通常称为体素。这个立方体递归地细分为八个子立方体，直到分割成最小的体素。最小体素的大小决定了八叉树的分辨率，由于八叉树是一种分层数据结构，能够在任意层次切割得到不同分辨率的表达。八叉树在不同分辨率下的表示如图：<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/PCL-Learning-Notes/pcl-6.png" alt="cmd-markdown-logo"><br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/PCL-Learning-Notes/pcl-7.png" alt="cmd-markdown-logo"><br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/PCL-Learning-Notes/pcl-8.png" alt="cmd-markdown-logo"><br>由八叉树的表达方式可以看出，其优点在于：<br>(1)压缩空间：八叉树的节点存储了是否被占据的信息，当节点的所有子节点全部被占据或是全不占据时，就无需展开此节点，能够大大节省内存空间。<br>(2)更新地图：通过概率对数可以方便的对八叉树地图进行更新。<br>(3)导航与避障：八叉树地图每个体素表示其被占据的概率，机器人可以很方便地对八叉树地图进行空间可行性分析和路径规划。并且八叉树地图分辨率可调，可以灵活地将不同分辨率的地图应用于不同层次的导航。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/PCL-Learning-Notes/pcl-9.png" alt="cmd-markdown-logo"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font size=&quot;3&quot;&gt;点云库(PCL:Point Cloud Library)学习笔记&lt;/font&gt;

&lt;p&gt;1、了解名词&lt;br&gt;(1)点云：通过测量仪器得到的产品外观表面的点数据集合称之为点云，使用三维激光扫描仪或照相式扫描仪得到的点云，点数量比较大并且比较密集，叫密集
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Turtlebot2 rgbslam_v2 三维地图建模</title>
    <link href="http://yoursite.com/2019/05/18/Turtlebot2-rgbslam-3D-Mapping/"/>
    <id>http://yoursite.com/2019/05/18/Turtlebot2-rgbslam-3D-Mapping/</id>
    <published>2019-05-18T01:36:29.000Z</published>
    <updated>2019-05-31T16:00:16.747Z</updated>
    
    <content type="html"><![CDATA[<p><font size="3">Turtlebot2 rgbslam_v2 三维地图建模</font><br>此篇文章转载博客:<code>www.guyuehome.com/860</code><br>1、启动UI<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ roslaunch freenect_launch freenect.launch</span><br><span class="line">$ roslaunch rgbdslam rgbdslam.launch</span><br></pre></td></tr></table></figure></p><p>或者：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ roslaunch rgbdslam openni+rgbdslam.launch(启动界面)</span><br></pre></td></tr></table></figure></p><p><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/3D-Mapping/1.jpg" alt="waitting"><br>2、启动底座和遥控<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ roslaunch turtlebot_bringup minimal.launch(启动底座)</span><br><span class="line">$ roslaunch turtlebot_teleop keyboard_teleop.launch(启动遥控)</span><br></pre></td></tr></table></figure></p><p>3、建立地图<br>按下rgbd-slam-v2的空白键，让机器人四处走起来。UI的状态栏会显示程序的运行状态，有提取特征、加入新Frame，等等。如果它成功匹配上，上图的点云就会更新，并且会跟着机器人转动。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/3D-Mapping/2.png" alt="waitting"><br>别看上面像是打了码一样的，最后出的点云图可是高清无码的。<br>4、保存地图<br>建模完成后，直接在菜单栏中选择保存成点云数据即可。<br>5、查看地图<br>然可以通过pcl_ros（<a href="http://wiki.ros.org/pcl_ros" target="_blank" rel="noopener">http://wiki.ros.org/pcl_ros</a> ）来查看保存的点云地图：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun pcl_ros pcd_to_pointcloud quicksave.pcd</span><br></pre></td></tr></table></figure></p><p>在rviz中显示pointcloud2数据：<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/3D-Mapping/3.jpg" alt="waitting"><br>6、总结<br>Rgbd-slam-v2是14年论文里提到的算法。它整合了SLAM领域里的各种技术：图像特征、回环检测、点云、图优化等等，是一个非常全面且优秀的程序。它的UI做的也很漂亮，可以在它的源代码上继续开发。<br>缺点：在美观之外，由于要提特征（SIFT很费时）、渲染点云，这些事情是很吃资源的，导致算法实时性不太好。有时会发现它卡在那儿不动了，不得不等它一小会。机器人如果走的太快，很容易跟丢。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;font size=&quot;3&quot;&gt;Turtlebot2 rgbslam_v2 三维地图建模&lt;/font&gt;&lt;br&gt;此篇文章转载博客:&lt;code&gt;www.guyuehome.com/860&lt;/code&gt;&lt;br&gt;1、启动UI&lt;br&gt;    &lt;figure class=&quot;highlig
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Turtlebot2 rgbdslam_v2环境配置</title>
    <link href="http://yoursite.com/2019/05/18/Turtlebot2-rgbdslam-Environment/"/>
    <id>http://yoursite.com/2019/05/18/Turtlebot2-rgbdslam-Environment/</id>
    <published>2019-05-17T23:31:00.000Z</published>
    <updated>2019-05-18T05:20:06.091Z</updated>
    
    <content type="html"><![CDATA[<font size="3">Turtlebot2 rgbdslam_v2环境配置</font><p>1、创建一个工作空间，编译一遍<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p ~/catkin_ws/src</span><br><span class="line">$ cd ~/catkin_ws</span><br><span class="line">$ catkin_make</span><br></pre></td></tr></table></figure></p><p>2、下载rgbdslam_v2代码包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/catkin_ws/src</span><br><span class="line">$ wget -q http://github.com/felixendres/rgbdslam_v2/archive/kinetic.zip</span><br><span class="line">$ unzip kinetic.zip</span><br><span class="line">(把解压出来的文件名更改为rgbdslam_v2)</span><br><span class="line">$ sudo cp -a ~/catkin_ws/src/rgbdslam_v2 /opt/ros/kinetic/share</span><br></pre></td></tr></table></figure></p><p>3、安装g2o的依赖<br>sudo apt-get install libsuitesparse-dev<br>4、创建eigen工作空间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ~/src</span><br><span class="line">$ cd ~/src</span><br><span class="line">$ wget http://bitbucket.org/eigen/eigen/get/3.2.10.tar.bz2</span><br><span class="line">mkdir eigen</span><br><span class="line">$ tar -xvjf 3.2.10.tar.bz2 -C eigen --strip-components 1</span><br></pre></td></tr></table></figure></p><p>5、创建g2o工作空间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/src</span><br><span class="line">$ git clone https://github.com/felixendres/g2o.git</span><br><span class="line">$ cd ~/src/g2o</span><br><span class="line">$ mkdir ~/src/g2o/build</span><br><span class="line">$ cd ~/src/g2o/build</span><br></pre></td></tr></table></figure></p><p>6、配置g2o代码包中的CMakeLists.txt文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ vi ~/src/g2o/CMakeLists.txt</span><br><span class="line">(如果不习惯vi 可以执行 sudo gedit ~/src/g2o/CMakeLists.txt</span><br><span class="line"> 也可以使用atom文本编辑器打开)</span><br><span class="line">在251行中：</span><br><span class="line">将SET(G2O_EIGEN3_INCLUDE $&#123;EIGEN3_INCLUDE_DIR&#125; CACHE PATH &quot;Directory of Eigen3&quot;)</span><br><span class="line">替换为SET(G2O_EIGEN3_INCLUDE &quot;~/src/eigen&quot; CACHE PATH &quot;Directory of Eigen3&quot;)</span><br><span class="line">保存退出</span><br></pre></td></tr></table></figure></p><p>7、编译g2o工作空间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/src/g2o/build</span><br><span class="line">$ cmake ../</span><br><span class="line">$ make</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure></p><p>8、下载PCL1.8(点云库：Point Cloud Library)<br>在此过程中，采用了很多方法，但都失败了，最后直接找到源代码的位置，下载zip文件(tar文件无法下载),下载之后放在~/src目录下解压。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/src</span><br><span class="line">$ unzip pcl-pcl-1.8.0.zip</span><br></pre></td></tr></table></figure></p><p>9、配置PCL,使其支持C++2011<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/src/pcl-pcl-1.8.0</span><br><span class="line">$ vi CMakeLists.txt(或者sudo gedit CMakeLists.txt)</span><br><span class="line">在146行(endif()下一行)中加入SET(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++11&quot;)</span><br></pre></td></tr></table></figure></p><p>10、编译PCL<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/src/pcl-pcl-1.8.0</span><br><span class="line">$ mkdir build</span><br><span class="line">$ cd build</span><br><span class="line">$ cmake ../</span><br><span class="line">$ make VERBOSE=1 (此步骤是为了验证PCL是否支持C++2011，如果能在输出中看到&quot;-std=c++11&quot;，则说明是支持的，没有问题,按Ctrl+C退出，执行下一行命令。)</span><br><span class="line">$ make</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure></p><p>11、配置rgbdslam_v2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/catkin_ws/src/rgbdslam_v2</span><br><span class="line">$ vi CMakeLists.txt(sudo gedit CMakeLists.txt)</span><br><span class="line">在第六行中加入:add_compile_options(-std=c++11)</span><br><span class="line">之后将find_package(PCL 1.7 REQUIRED COMPONENTS common io)</span><br><span class="line">替换为:</span><br><span class="line">find_package(PCL 1.8 REQUIRED COMPONENTS common io)</span><br></pre></td></tr></table></figure></p><p>12、编译rgbdslam_v2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/catkin_ws</span><br><span class="line">$ source devel/setup.bash</span><br><span class="line">$ cd ~/catkin_ws/src/rgbdslam_v2</span><br><span class="line">$ catkin_make</span><br><span class="line">$ source devel/setup.bash</span><br><span class="line">$ echo &quot;source ~/catkin_ws/devel/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure></p><p>13、环境测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ roslaunch freenect_launch freenect.launch</span><br><span class="line">(或者输入:roslaunch openni_launch openni.launch,如果没有设备连接，会显示&quot;waiting for devices to be connected&quot;)</span><br><span class="line">$ roslaunch rgbdslam openni+rgbdslam.launch(运行此命令就可以看到一个UI的界面了)</span><br></pre></td></tr></table></figure></p><p>14、查看地图<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rosrun pcl_ros pcd_to_pointcloud quicksave.pcd</span><br></pre></td></tr></table></figure></p><p>有关博客参考：<br><code>https://hubpages.com/technology/Instructions-for-compiling-rgbdslam-v2-on-a-fresh-Ubuntu-1604-install-ros-kinetic-in-virtualbox</code><br><code>https://blog.csdn.net/u011178262/article/details/83046256</code><br><code>https://blog.csdn.net/yangtze_1006/article/details/51606680</code><br><code>www.guyuehome.com/860</code><br><code>https://www.cnblogs.com/gaoxiang12/p/4462518.html</code><br><code>https://github.com/felixendres/rgbdslam_v2</code><br><code>https://www.ncnynl.com/archives/201708/1931.html</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font size=&quot;3&quot;&gt;Turtlebot2 rgbdslam_v2环境配置&lt;/font&gt;

&lt;p&gt;1、创建一个工作空间，编译一遍&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>turtlebot2-kinetic环境配置</title>
    <link href="http://yoursite.com/2019/05/16/Turtlebot2-Kinetic-Environment/"/>
    <id>http://yoursite.com/2019/05/16/Turtlebot2-Kinetic-Environment/</id>
    <published>2019-05-16T11:08:25.000Z</published>
    <updated>2019-05-16T11:50:40.463Z</updated>
    
    <content type="html"><![CDATA[<font size="3">Turtlebot2-kinetic环境配置</font><p>•安装准备<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install python-rosdep python-wstool ros-kinetic-ros</span><br><span class="line">$ sudo apt-get install pyqt5-dev-tools</span><br><span class="line">$ sudo rosdep init</span><br><span class="line">$ rosdep update</span><br></pre></td></tr></table></figure></p><p>•分别建立三个工作空间rocon，kobuki，turtlebot，下载和编译源码<br>•建立rocon目录，下载和编译，rocon都有对应的kinetic版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ~/rocon</span><br><span class="line">$ cd ~/rocon</span><br><span class="line">$ wstool init -j4 src https://raw.github.com/robotics-in-concert/rocon/release/kinetic/rocon.rosinstall</span><br><span class="line">（注意：如该下载失败，到github中找到相应文件进行配置）</span><br><span class="line">$ source /opt/ros/kinetic/setup.bash</span><br><span class="line">$ rosdep install --from-paths src -i -y</span><br><span class="line">$ catkin_make</span><br></pre></td></tr></table></figure></p><p>•建立kobuki目录，下载和编译.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ~/kobuki</span><br><span class="line">$ cd ~/kobuki</span><br><span class="line">$ wstool init -j4 src https://raw.githubusercontent.com/yujinrobot/yujin_tools/kinetic-devel/rosinstalls/kinetic/kobuki.rosinstall</span><br><span class="line">$ source ~/rocon/devel/setup.bash</span><br><span class="line">$ rosdep install --from-paths src -i -y</span><br><span class="line">$ catkin_make</span><br></pre></td></tr></table></figure></p><p>•建立turtlebot目录，下载和编译.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ~/turtlebot</span><br><span class="line">$ cd ~/turtlebot</span><br><span class="line">$ wstool init -j4 src https://raw.github.com/yujinrobot/yujin_tools/kinetic-devel/rosinstalls/kinetic/turtlebot.rosinstall</span><br><span class="line">$ source ~/kobuki/devel/setup.bash</span><br><span class="line">$ rosdep install --from-paths src -i -y</span><br><span class="line">$ catkin_make</span><br></pre></td></tr></table></figure></p><p>•添加工作空间到bashrc文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;source ~/rocon/devel/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">$ echo &quot;source ~/kobuki/devel/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">$ echo &quot;source ~/turtlebot/devel/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure></p><p>•启用新环境：<br><code>$ source ~/.bashrc</code><br>•测试环境生效：<br><code>$ roscd turtlebot</code><br>能正常进入到目录就说明成功</p><p>•生成kobuki别名<br><code>$ rosrun kobuki_ftdi create_udev_rules</code></p><p>•安装kinect驱动<br><code>$ sudo apt-get install ros-kinetic-openni-* ros-kinetic-openni2-* ros-kinetic-freenect-*</code></p><p><font size="3">Turtlebot-kinetic测试</font><br>测试Turtlebot安装（Turtlebot和工作站）</p><p>在工控机中，新开终端输入<br><code>$ roscore</code><br>如果ROS安装正确显示<br><code>$ started core service [/rosout]</code></p><p>如有问题，请检查安装步骤！<br>检查别名：<br> •输入检测命令：<br><code>$ ls /dev/kobuki</code><br> •会显示有对应的设备/dev/kobuki<br> •如果没有，添加别名：<br><code>$ rosrun kobuki_ftdi create_udev_rules</code><br> •重插USB线，在进行上述的检测命令</p><p> •通过遥控移动（仅TurtleBot，通过Turtlebot的上网本操作）<br> 1.打开Turtlebot开关，状态点亮。<br> 2.启动Turtlebot，在上网本，打开一个新终端，运行如下命令：<br><code>$ roslaunch turtlebot_bringup minimal.launch</code><br> 3.启动键盘遥控，在上网本，打开另一个新终端，运行如下命令：<br><code>$ roslaunch turtlebot_teleop keyboard_teleop.launch</code><br> 4.点击键盘“i”前进。</p><p>通过发布主题命令<br> •命令：<br><code>$ rostopic pub -r 10 /cmd_vel_mux/input/navi  geometry_msgs/Twist  &#39;{linear:  {x: 0.1, y: 0.0, z: 0.0}, angular: {x: 0.0,y: 0.0,z: 0.0}}&#39;</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font size=&quot;3&quot;&gt;Turtlebot2-kinetic环境配置&lt;/font&gt;

&lt;p&gt;•安装准备&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;li
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>turtlebot2-indigo环境配置</title>
    <link href="http://yoursite.com/2019/05/16/turtlebot2-Indigo-Environment/"/>
    <id>http://yoursite.com/2019/05/16/turtlebot2-Indigo-Environment/</id>
    <published>2019-05-16T11:08:05.000Z</published>
    <updated>2019-05-16T11:50:38.361Z</updated>
    
    <content type="html"><![CDATA[<font size="3">Turtlebot2-indigo环境配置</font><p>安装步骤<br>    有两种安装方法，一种直接的安装命令，另外一种源码编译安装，区别在于：直接安装命令是安装在电脑默认路径/opt/ros/indigo/share里面不便于更改代码，因为默认路径下文件一般有访问权限，无法直接更改，需要使用sudo chmod -R 777 /opt更改其权限，使得每个使用的人都可以更改；源码编译，安装的文件在Home主目录中,方便更改。</p><p>1、直接安装命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install ros-indigo-turtlebot ros-indigo-turtlebot-apps ros-indigo-turtlebot-interactions ros-indigo-turtlebot-simulator ros-indigo-kobuki-ftdi ros-indigo-rocon-remocon ros-indigo-rocon-qt-library ros-indigo-ar-track-alvar-msgs</span><br></pre></td></tr></table></figure></p><p>2、源码方式安装<br> 1)先安装依赖项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install python-rosdep python-wstool ros-indigo-ros</span><br><span class="line">$ sudo rosdep init</span><br><span class="line">$ rosdep update</span><br></pre></td></tr></table></figure></p><p> 2)建立Turtlebot工作空间</p><p>#创建三个文件夹，分别存放rocon、kobuki、turtlebot，复制相应的代码、设置文件所在路径工作环境、编译<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ~/rocon</span><br><span class="line">$ cd ~/rocon</span><br><span class="line">$ wstool init -j5 src https://raw.github.com/robotics-in-concert/rocon/release/indigo/rocon.rosinstall</span><br><span class="line">$ source /opt/ros/indigo/setup.bash</span><br><span class="line">$ rosdep install --from-paths src -i -y</span><br><span class="line">$ catkin_make</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ~/kobuki</span><br><span class="line">$ cd ~/kobuki</span><br><span class="line">$ wstool init src -j5 https://raw.github.com/yujinrobot/yujin_tools/master/rosinstalls/indigo/kobuki.rosinstall</span><br><span class="line">$ source ~/rocon/devel/setup.bash</span><br><span class="line">$ rosdep install --from-paths src -i -y</span><br><span class="line">$ catkin_make</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ~/turtlebot</span><br><span class="line">$ cd ~/turtlebot</span><br><span class="line">$ wstool init src -j5 https://raw.github.com/yujinrobot/yujin_tools/master/rosinstalls/indigo/turtlebot.rosinstall</span><br><span class="line">$ source ~/kobuki/devel/setup.bash</span><br><span class="line">$ rosdep install --from-paths src -i -y</span><br><span class="line">$ catkin_make</span><br></pre></td></tr></table></figure><p>安装完成后，测试命令：<br><code>$ roslaunch turtlebot_bringup minimal.launch</code><br>如果正常可以看到以下界面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">... logging to /home/fjx/.ros/log/e9549e36-850f-11e8-ab48-543530c06929/roslaunch-giimbot-19656.log</span><br><span class="line">Checking log directory for disk usage. This may take awhile.</span><br><span class="line">Press Ctrl-C to interrupt</span><br><span class="line">Done checking log file disk usage. Usage is &lt;1GB.</span><br><span class="line">started roslaunch server http://giimbot:36504/</span><br><span class="line">SUMMARY</span><br><span class="line">========</span><br><span class="line">PARAMETERS</span><br><span class="line"> * /app_manager/auto_rapp_installation: False</span><br><span class="line"> * /app_manager/auto_start_rapp:</span><br><span class="line"> ...........(中间省略)</span><br><span class="line">process[interactions-12]: started with pid [19769]</span><br><span class="line">process[zeroconf/zeroconf-13]: started with pid [19781]</span><br><span class="line">[ INFO] [1531316403.920700304]: Zeroconf: service successfully established [turtlebot][_ros-master._tcp][11311]</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font size=&quot;3&quot;&gt;Turtlebot2-indigo环境配置&lt;/font&gt;


&lt;p&gt;安装步骤&lt;br&gt;    有两种安装方法，一种直接的安装命令，另外一种源码编译安装，区别在于：直接安装命令是安装在电脑默认路径/opt/ros/indigo/share里面不便于更改代
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>基于legacy引导方式的win7-linux双系统</title>
    <link href="http://yoursite.com/2019/04/29/%E5%9F%BA%E4%BA%8Elegacy%E5%BC%95%E5%AF%BC%E6%96%B9%E5%BC%8F%E7%9A%84win7-linux%E5%8F%8C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2019/04/29/基于legacy引导方式的win7-linux双系统/</id>
    <published>2019-04-29T13:34:57.000Z</published>
    <updated>2019-05-31T14:10:02.659Z</updated>
    
    <content type="html"><![CDATA[<p>写到这篇文章，笔者还是很有感触，因为我在大一的时候给电脑装双系统，用的是上一篇文章win10-linux的常规方法，也是用U盘作为启动项，但死活就是安装不上。之后才发现原因，我电脑的win7系统的引导方式是legacy，而常规方法安装的linux系统恰好是uefi引导方式，硬装是装不上的。如果你的电脑也是legacy引导方式想装双系统，其实很简单，这篇文章就可以解决你的问题。</p><p><strong><font size="3">操作步骤</font></strong></p><p> (1)准备两个东西：<br>    1) ubuntu镜像文件，网上自行下载(最好是到官网上去下载，靠谱)，这里以ubuntu16.04为例。<br>    2) EasyBCD软件，网上自行下载(最好是安装版，不要绿色版)。</p><p> (2)分区。计算机右键-管理-磁盘管理，选中一个磁盘(这里以D盘为例)右键磁盘压缩，压缩空间自己定，这个空间就是给linux系统，最好不要小于20G。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win-linux/1-1.png" alt="waitting"></p><p> (3)打开EasyBCD软件，添加linux引导项。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win-linux/1-2.png" alt="waitting"></p><p> (4)安装之后，点击配置，进行文件配置，然后就会出现一个menu.lst文件，我们要编辑这个文件 因为系统就是这个文件找到我们的Ubuntu的。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win-linux/1-3.png" alt="waitting"></p><p><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win-linux/1-4.png" alt="waitting"></p><p>把下面的 英文 复制进去，把原来的全覆盖掉<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title Install Ubuntu</span><br><span class="line">root (hd0,0)</span><br><span class="line">kernel (hd0,0)/vmlinuz.efi boot=casper iso-scan/filename=/ubuntu-16.04.2-desktop-amd64.iso ro quiet splash locale=zh_CN.UTF-8</span><br><span class="line">initrd (hd0,0)/initrd.lz</span><br></pre></td></tr></table></figure></p><p> 特别注意:<br>  1)上图代码中”ubuntu-16.04.2-desktop-amd64.iso”是你下载ubuntu系统文件名，这个文件名是可以修改的，但修改的名字一定要与写入的代码名字一致，否则将无法安装。<br>  2)在64位中casper目录下为vmlinuz.efi，32位的才是vmlinuz（本人亲测，在安装过程中碰到error 15 file not find 错误，就是因为这个问题）<br>  3)对于有的电脑上你的第一个盘符并不是C盘，在磁盘管理中可以看出，所以安装时需将(hd0,0)改为（hd0,1）(假设为第二个)。</p><p> (5)ubuntu-16.04.2-desktop-amd64.iso镜像文件用压缩软件或者虚拟光驱打开，找到casper文件夹，把里面的initrd.lz和vmlinuz.efi解压到C盘，把.disk文件夹也解压到C盘，然后在把ubuntu-16.04.2-desktop-amd64.iso文件也复制到C盘。当然你也可以将这三个文件复制到别的盘符，但一定要与代码中的盘符相对应。比如我想在把文件复制到D盘，则代码中要将(hd0,0)改为相应D盘的盘符(hd0,1)。</p><p> (6)重启，就会看到有2个启动菜单，我们选择NeoGrub引导加载器，过一会就出现ubuntu系统的界面。</p><p> (7)有的电脑是双显卡，重启可能会在出现ubuntu图标时卡住(如果没卡请忽略)，这时因为独立显卡的问题，需要把它禁用掉，重启到win7系统，将EasyBCD配置文件改为如下：<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win-linux/1-5.png" alt="waitting"><br> 然后再重启，加载引导就可以进入ubuntu界面了。</p><p> (8)这个步骤非常重要，出现界面之后，不要着急点安装，按Ctrl+Alt+t打开终端，输入代码:sudo umount -l /isodevice这一命令取消掉对光盘所在驱动器的挂载(注意，这里的-l是-L的小写，-l与/isodevice之间有一个空格)，否则分区界面找不到分区。</p><p> (9)然后点击ubuntu桌面的”install ubuntu”进入安装，在进行到“安装类型”的时候，我们可以选择“安装ubuntu，与Windows7共存”，这样就可以不用自己分区，非常简便，我们也可以选择“其它选项”，这样就需要自己来分区(此处不详细讲解)，其他的安装步骤正常安装即可。安装完成后，如果刚才(7)界面卡住，先不要重启，因为新系统没有配置Grub文件，重启还会卡住。此时要按Ctrl+Alt+T打开终端，输入sudo gedit /boot/grub.cfg 在出现的文档中搜索splash，并在其后加一个空格然后输入nomodeset并保存文档，就OK了。</p><p> (10)重启，就可以看见粉色的引导界面，有“ubunut”和“windows7”(win7在最下面)，这就是ubuntu引导带着win7一起启动，至此双系统安装成功。</p><p> (11)进入ubuntu系统后，按Ctrl+Alt+t打开终端，输入”sudo mv /et/grub.d/30_os-prober /etc/grub.d/06_os-prober”然后输入密码回车，再输入”sudo update-grub”,输入密码回车，此时，win7系统引导就在最上面了，每次开机就默认进入win7系统。</p><p> (12)重启进入win7，打开EasyBCD，移除nerogrub引导项(此步骤不做也可，没有什么影响)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写到这篇文章，笔者还是很有感触，因为我在大一的时候给电脑装双系统，用的是上一篇文章win10-linux的常规方法，也是用U盘作为启动项，但死活就是安装不上。之后才发现原因，我电脑的win7系统的引导方式是legacy，而常规方法安装的linux系统恰好是uefi引导方式，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>基于uefi引导方式的win10-linux双系统</title>
    <link href="http://yoursite.com/2019/04/28/%E5%9F%BA%E4%BA%8Euefi%E5%BC%95%E5%AF%BC%E6%96%B9%E5%BC%8F%E7%9A%84win10-linux%E5%8F%8C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2019/04/28/基于uefi引导方式的win10-linux双系统/</id>
    <published>2019-04-28T13:36:00.000Z</published>
    <updated>2019-05-31T16:02:27.516Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章是装win10-linux双系统最基本的方法，如果你的电脑是uefi引导的win10系统，这个方法可行。但是强调一点，如果是弘基电脑，那么请您绕行，对于弘基电脑来说，这种方法是不可行的。本人装过弘基电脑的双系统，但是装完之后会发现直接进入win10系统，没有linux的引导，还需要在win10系统中用EasyUEFI这个软件来手动添加linux引导项，非常的麻烦，之后还会有许多的bug，需要不定期的进行维护。本人也请教过专业人士，但也没有办法，弘基电脑就是只能这样。下面进入正题，常规方法安装双系统。</p><p><strong><font size="4">操作步骤</font></strong></p><p> (1)准备三个东西：<br>    1)ubuntuIOS镜像文件，网上自行下载(建议到官网下载，靠谱)<br>    2)刻录软件，这里用的是rufus<br>    3)U盘，最好不小于4G</p><p> (2)分区。计算机右键-管理-磁盘管理，选中一个磁盘(这里以D盘为例)右键磁盘压缩，压缩空间自己定，这个空间就是给linux系统，最好不要小于20G。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win-linux/1-1.png" alt="waitting"></p><p> (3)刻录系统文件。刻录之前插入你的U盘，格式化。打开rufus软件设备选择你插入的U盘，软件会自动识别，镜像文件就选择你下载好ubuntu镜像文件，其它都是默认，不用改变。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win-linux/2-1.png" alt="waitting"></p><p><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win-linux/2-2.jpg" alt="waitting"></p><p> 然后点击开始出现以下界面：选择以IOS镜像模式写入，点击OK，就开始刻录，完成之后点击关闭。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win-linux/2-3.png" alt="waitting"></p><p> (4)拔出U盘，重启进入bios，设置U盘启动项，关机。</p><p> (5)插入U盘，启动电脑，按指定键进入选择启动项的界面，然后选择插入的U盘，回车之后就会看到ubuntu的引导界面。</p><p> (6)接下来选择第二个选项”Install Ubuntu”，进入安装。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win-linux/2-4.png" alt="waitting"></p><p> (7)左边的栏里选择“中文简体”，之后点击安装Ubuntu<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win-linux/2-5.png" alt="waitting"></p><p> (8)先不联网，直接安装。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win-linux/2-6.png" alt="waitting"></p><p> (9)继续安装<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win-linux/2-7.png" alt="waitting"></p><p> (10)到了最关键的一步了，这个时候系统会提示你是否与windows10共存。如果是新手，我们可以选择与win10共存，这样就避免了分区，非常简便。如果你想自己管理你的分区，那么就选择其他选项进行自定义分区。这里选择与windows10共存。<br> 注意:如果系统没提示你之前安装过windows，那么你的启动方式就错误了，你得回到BIOS页面下更改启动方式再次启动。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win-linux/2-8.png" alt="waitting"></p><p> (11)选择上海。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win-linux/2-9.png" alt="waitting"></p><p> (12)选择汉语。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win-linux/2-10.png" alt="waitting"></p><p> (13)设置账号和密码。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win-linux/2-11.png" alt="waitting"></p><p> (14)安装完成后重启系统会看到此界面，这就说明安装成功，ubuntu的引导带着win10的引导一起启动，这时可以选择你想进入的系统。这个界面排在第一位的是”ubuntu”,这样每次开机默认进入的是ubuntu系统，可以把win10系统排在第一位。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win-linux/2-12.png" alt="waitting"></p><p> (15)进入ubuntu系统，按Ctrl+Altr+t打开命令行，输入命令：<br><code>sudo gedit /etc/default/grub</code>,要修改默认启动顺序，找到如下行<br><code>GRUB_DEFAULT=0</code><br> 该行就是启动时默认的选项,修改为自己Windows所在的值。例如我的启动项是(可以在启动界面看到)：<br>  0.Ubuntu启动<br>  1.Ubuntu配置<br>  2.Windows启动<br> 所以修改为<code>GRUB_DEFAULT=2</code>，重启后就可以看到，windows10排在了第一位，每次开机默认进入win10系统。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇文章是装win10-linux双系统最基本的方法，如果你的电脑是uefi引导的win10系统，这个方法可行。但是强调一点，如果是弘基电脑，那么请您绕行，对于弘基电脑来说，这种方法是不可行的。本人装过弘基电脑的双系统，但是装完之后会发现直接进入win10系统，没有linu
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>基于python和机器学习的微信跳一跳小程序破解</title>
    <link href="http://yoursite.com/2019/04/28/%E5%9F%BA%E4%BA%8Epython%E5%92%8C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%BE%AE%E4%BF%A1%E8%B7%B3%E4%B8%80%E8%B7%B3%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%A0%B4%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/04/28/基于python和机器学习的微信跳一跳小程序破解/</id>
    <published>2019-04-28T13:33:46.000Z</published>
    <updated>2019-05-31T16:32:15.931Z</updated>
    
    <content type="html"><![CDATA[<video id="video" controls preload="none" poster="http://om2bks7xs.bkt.clouddn.com/2017-08-26-Markdown-Advance-Video.jpg"><br><source id="mp4" src><br></video>]]></content>
    
    <summary type="html">
    
      
      
        &lt;video id=&quot;video&quot; controls preload=&quot;none&quot; poster=&quot;http://om2bks7xs.bkt.clouddn.com/2017-08-26-Markdown-Advance-Video.jpg&quot;&gt;&lt;br&gt;&lt;source id=&quot;mp
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>最简单的方法重装win10系统</title>
    <link href="http://yoursite.com/2019/04/27/%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%B9%E6%B3%95%E9%87%8D%E8%A3%85win10%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2019/04/27/最简单的方法重装win10系统/</id>
    <published>2019-04-27T13:53:41.000Z</published>
    <updated>2019-05-31T14:03:32.478Z</updated>
    
    <content type="html"><![CDATA[<p><font size="3">到Microsoft官网下载安装工具,用这个工具安装win10系统非常方便。利用此工具不仅可以在原有系统重装win10，也可以用来做U盘启动项。</font><br><code>https://www.microsoft.com/zh-cn/software-download/windows10</code></p><p><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win10/2-42.jpg" alt="waitting"></p><p><strong><font size="3">操作步骤</font></strong></p><p>1.如果电脑系统还可以进入，那就没必要做U盘启动项，直接在现有的系统里重装win10。</p><p> (1)右键，以管理员身份运行下载好的工具，利用工具下载Windows10原版系统。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win10/2-48.jpg" alt="waitting"></p><p> (2)选择第二个(下载IOS文件)，点下一步。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win10/2-43.jpg" alt="waitting"></p><p> (3)把“对这台电脑使用推荐的选项”对号去掉，就可以选择想要的系统。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win10/2-45.jpg" alt="waitting"></p><p> (4)此处选择IOS文件(U盘在后文中讲解)，点下一步。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win10/2-46.jpg" alt="waitting"></p><p> (5)开始下载win10系统，这系统是原版的系统，个人认为比那些在其他网站上下载的乱七八糟的系统要好。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win10/2-47.jpg" alt="waitting"></p><p> (6)将下载好的IOS文件解压到C盘之外的一个文件夹，这些文件就是安装系统所需要的文件啦。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win10/2-39.jpg" alt="waitting"></p><p> (7)右键“setup.exe”，以管理员身份运行，就开始安装系统了。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win10/2-1.jpg" alt="waitting"></p><p> (8)顺利进入安装向导，检查安装环境。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win10/2-2.jpg" alt="waitting"></p><p> (9)不更新，直接安装，速度更快，点击下一步。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win10/2-3.jpg" alt="waitting"></p><p> (10)这里选择win10专业版，可以根据自己的情况选择。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win10/2-4.jpg" alt="waitting"></p><p> (11)点击下一步。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win10/2-5.jpg" alt="waitting"></p><p> (12)看个人需要是否选择保留文件。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win10/2-6.jpg" alt="waitting"></p><p> (13)确认无误后安装，点击下一步。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win10/2-7.jpg" alt="waitting"></p><p> (14)开始安装，期间会多次重启，请耐心等待。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win10/2-8.jpg" alt="waitting"></p><p> (15)这个不解释。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win10/2-9.jpg" alt="waitting"></p><p> (16)不解释。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win10/2-10.jpg" alt="waitting"></p><p> (17)不解释。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win10/2-11.jpg" alt="waitting"></p><p> (18)选择针对个人。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win10/2-12.jpg" alt="waitting"></p><p> (19)创建账户和密码。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win10/2-13.jpg" alt="waitting"></p><p> (20)不解释。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win10/2-14.jpg" alt="waitting"></p><p> (21)不解释。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win10/2-15.jpg" alt="waitting"></p><p> (22)选择稍后再做。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win10/2-16.jpg" alt="waitting"></p><p> (23)根据需要选择。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win10/2-17.jpg" alt="waitting"></p><p> (24)一些设置。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win10/2-18.jpg" alt="waitting"></p><p> (25)配置电脑硬件，等一会就好了。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win10/2-19.jpg" alt="waitting"></p><p><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win10/2-20.jpg" alt="waitting"></p><p> (26)敬请开始吧！<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win10/2-21.jpg" alt="waitting"></p><p> (27)全新的win10系统！<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win10/2-22.jpg" alt="waitting"></p><p> (28)设置桌面图标：在桌面右键&gt;个性化&gt;主题&gt;桌面图标设置， 然后勾选你所需要显示的图标即可<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win10/2-23.jpg" alt="waitting"></p><p> (29)查看系统激活情况。右键此电脑&gt;属性查看，新系统是没有激活的，下载一个系统激活软件，进行激活。(此处不做过多讲解)<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win10/2-24.jpg" alt="waitting"></p><p>2.如果你的系统坏了，进不去了，这时你就要用U盘作为启动项安装系统。<br> (1)进入电脑Bios界面，设置引导模式，设置U盘启动。</p><p> (2)借一台同学的电脑，下载安装工具，文章开头已经写到。</p><p> (3)右键，以管理员身份运行下载好的工具，利用工具下载Windows10原版系统。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win10/2-48.jpg" alt="waitting"></p><p> (4)选择第二个(做系统U盘)，点下一步。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win10/2-44.jpg" alt="waitting"></p><p> (5)选择系统<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win10/2-45.jpg" alt="waitting"></p><p> (6)选择U盘，之后选择自己插入电脑的U盘，此过程是先下载系统，之后再刻录文件，所以时间比较漫长。如果你有自己的系统文件，比如之前下载IOS文件，就可以用刻录软件将系统直接刻录到U盘里。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win10/2-46.jpg" alt="waitting"></p><p> (7)将刻录好的U盘插进要装系统的电脑，开机按指定键选择启动项。（不同电脑，按键不同。）<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win10/2-41.jpg" alt="waitting"></p><p> (8)上下键选择U盘，回车进入即可安装系统，之后的步骤与上一种方法相同。<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/win10/2-40.jpg" alt="waitting"></p><p> (9)U盘可以选择4G的U盘，刻录完之后就可以用这个U盘随时给电脑装系统啦。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;font size=&quot;3&quot;&gt;到Microsoft官网下载安装工具,用这个工具安装win10系统非常方便。利用此工具不仅可以在原有系统重装win10，也可以用来做U盘启动项。&lt;/font&gt;&lt;br&gt;&lt;code&gt;https://www.microsoft.com/zh-cn/s
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MBR分区与GPT分区互转方法</title>
    <link href="http://yoursite.com/2019/04/26/MBR%E5%88%86%E5%8C%BA%E4%B8%8EGPT%E5%88%86%E5%8C%BA%E4%BA%92%E8%BD%AC%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/04/26/MBR分区与GPT分区互转方法/</id>
    <published>2019-04-26T14:08:13.000Z</published>
    <updated>2019-05-31T13:58:06.096Z</updated>
    
    <content type="html"><![CDATA[<font size="3">系统引导的两种方式：</font><br>UEFI启动模式：（GPT分区表格式+ UEFI启动模式+ x64的系统）<br>Legacy启动模式：（MBR主引导记录分区格式+ Legacy启动模式）<br><br>UEFI是新式的BIOS，Legacy是传统BIOS。在UEFI 模式下安装的系统，只能用UEFI模式引导；同理，如果在Legacy模式下安装的系统，也只能在Legacy模式下进系统。<br><br>UEFI可以引导win7和win10系统，但是磁盘分区必须是GPT模式，系统必须是64位，UEFI不支持32位系统。legacy也可以引导win7和win10系统，磁盘分区必须是MBR模式，系统可以是32位也可以是64位。<br><br>如果安装win10系统，推荐UEFI+GPT。因为win10系统默认就是uefi+gpt模式，这样才能发挥最佳性能。<br>如果安装win7系统，推荐legacy+MBR。<br>这两种搭配最常见的搭配，安装的系统不容易出现问题，其他的搭配个人觉得没有什么必要。当然，还是要根据自己的电脑情况来决定。比如一些老旧机型不支持uefi，只能是legacy引导。<br><br><font size="3">磁盘的两种分区格式：</font><br><strong>MBR</strong>，即主引导记录<br><strong>GPT</strong>，GUID的缩写<br>GPT分区与MBR分区方法相比，GPT具有更多的优点。MBR分区表的硬盘最多能划分4个主分区磁盘，并且MBR最大仅支持2TB的硬盘，GPT分区表类型不受分区个数、硬盘大小的限制。<br><br>通常情况下，如果win10系统想重装win7，需要把GPT转换为MBR，如果win7系统想重装win10，需要把MBR装换为GPT。<br><br><font color="#DC143C" size="3">注意：转换分区格式过程中均会清除磁盘中的所有分区和数据，所以在操作前请注意备份硬盘中的文件。</font><p><strong><font size="4">操作步骤：</font></strong></p><p>1.GPT转换成MBR<br> (1)通过U盘做一个简单的PE维护系统开机进入</p><p> (2)运行磁盘管理软件DiskGenius(一般PE都自带)<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/MBR-GPT/1-1.jpg" alt="waitting"><br> (3)删除磁盘的所有分区</p><p><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/MBR-GPT/1-2.jpg" alt="waitting"><br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/MBR-GPT/1-3.jpg" alt="waitting"><br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/MBR-GPT/1-4.jpg" alt="waitting"></p><p> (4)在磁盘处右键，选择“转换分区表类型为MBR格式<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/MBR-GPT/1-5.jpg" alt="waitting"></p><p> (5)弹出如下提示窗口，选“确定”<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/MBR-GPT/1-6.jpg" alt="waitting"></p><p> (6)至此，转换成MBR格式成功<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/MBR-GPT/1-7.jpg" alt="waitting"></p><p> (7)最后，保存一下更改<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/MBR-GPT/1-8.jpg" alt="waitting"></p><p>（8）给新转换好格式的磁盘重新分区一下即可正常使用；分区方法请看下图，按箭头顺序操作即可<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/MBR-GPT/1-9.jpg" alt="waitting"></p><p>2.MBR转换成GPT<br> (1)进入PE系统</p><p> (2)运行磁盘管理软件DiskGenius(一般PE都自带)<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/MBR-GPT/1-1.jpg" alt="waitting"><br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/MBR-GPT/1-10.jpg" alt="waitting"></p><p> (3)删除原磁盘中的所有分区<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/MBR-GPT/1-11.jpg" alt="waitting"><br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/MBR-GPT/1-12.jpg" alt="waitting"></p><p> (4)在磁盘处右键，选择“转换分区表类型为GUID格式”<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/MBR-GPT/1-13.jpg" alt="waitting"></p><p> (5)弹出提示窗口，选“确定”<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/MBR-GPT/1-14.jpg" alt="waitting"></p><p> (6)最后，别忘了保存一下更改<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/MBR-GPT/1-16.jpg" alt="waitting"></p><p> (7)给新转换好格式的磁盘重新分区一下即可正常使用；分区方法请看下图，按箭头顺序操作即可<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/MBR-GPT/1-17.jpg" alt="waitting"></p><p> (8)最终效果<br><img src="https://github.com/YuemingBi/comment-repo/raw/master/image/MBR-GPT/1-18.jpg" alt="waitting"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font size=&quot;3&quot;&gt;系统引导的两种方式：&lt;/font&gt;&lt;br&gt;UEFI启动模式：（GPT分区表格式+ UEFI启动模式+ x64的系统）&lt;br&gt;Legacy启动模式：（MBR主引导记录分区格式+ Legacy启动模式）&lt;br&gt;&lt;br&gt;UEFI是新式的BIOS，Legac
      
    
    </summary>
    
    
  </entry>
  
</feed>
